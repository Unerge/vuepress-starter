// src/client/composables/codeRepl.ts
import { onMounted, ref } from "vue";
import { http } from "../utils/http.js";
import { sleep } from "../utils/sleep.js";

// src/client/composables/rustRepl.ts
import { tryOnScopeDispose } from "@vueuse/core";
var wsUrl = "wss://play.rust-lang.org/websocket";
var payloadType = {
  connected: "websocket/connected",
  request: "output/execute/wsExecuteRequest",
  execute: {
    begin: "output/execute/wsExecuteBegin",
    // status: 'output/execute/wsExecuteStatus',
    stderr: "output/execute/wsExecuteStderr",
    stdout: "output/execute/wsExecuteStdout",
    end: "output/execute/wsExecuteEnd"
  }
};
var ws = null;
var isOpen = false;
var uuid = 0;
function connect() {
  if (isOpen)
    return Promise.resolve();
  ws = new WebSocket(wsUrl);
  uuid = 0;
  ws.addEventListener("open", () => {
    isOpen = true;
    send(
      payloadType.connected,
      { iAcceptThisIsAnUnsupportedApi: true },
      { websocket: true, sequenceNumber: uuid }
    );
  });
  ws.addEventListener("close", () => {
    isOpen = false;
    ws = null;
  });
  tryOnScopeDispose(() => ws?.close());
  return new Promise((resolve) => {
    function connected(e) {
      const data = JSON.parse(e.data);
      if (data.type === payloadType.connected) {
        ws?.removeEventListener("message", connected);
        resolve();
      }
    }
    ws?.addEventListener("message", connected);
  });
}
function send(type, payload, meta) {
  const msg = { type, meta, payload };
  ws?.send(JSON.stringify(msg));
}
async function rustExecute(code, { onEnd, onError, onStderr, onStdout, onBegin }) {
  await connect();
  const meta = { sequenceNumber: uuid++ };
  const payload = {
    backtrace: false,
    channel: "stable",
    crateType: "bin",
    edition: "2021",
    mode: "release",
    tests: false,
    code
  };
  send(payloadType.request, payload, meta);
  let stdout = "";
  let stderr = "";
  function onMessage(e) {
    const data = JSON.parse(e.data);
    const { type, payload: payload2, meta: _meta = {} } = data;
    if (_meta.sequenceNumber !== meta.sequenceNumber)
      return;
    if (type === payloadType.execute.begin)
      onBegin?.();
    if (type === payloadType.execute.stdout) {
      stdout += payload2;
      if (stdout.endsWith("\n")) {
        onStdout?.(stdout);
        stdout = "";
      }
    }
    if (type === payloadType.execute.stderr) {
      stderr += payload2;
      if (stderr.endsWith("\n")) {
        if (stderr.startsWith("error:")) {
          const index = stderr.indexOf("\n");
          onStderr?.(stderr.slice(0, index));
          onStderr?.(stderr.slice(index + 1));
        } else {
          onStderr?.(stderr);
        }
        stderr = "";
      }
    }
    if (type === payloadType.execute.end) {
      if (payload2.success === false)
        onError?.(payload2.exitDetail);
      ws?.removeEventListener("message", onMessage);
      onEnd?.();
    }
  }
  ws?.addEventListener("message", onMessage);
}

// src/client/composables/codeRepl.ts
var ignoredNodes = [".diff.remove", ".vp-copy-ignore"];
var RE_LANGUAGE = /language-(\w+)/;
var api = {
  go: "https://api.pengzhanbo.cn/repl/golang/run",
  kotlin: "https://api.pengzhanbo.cn/repl/kotlin/run"
};
var langAlias = {
  kt: "kotlin",
  kotlin: "kotlin",
  go: "go",
  rust: "rust",
  rs: "rust"
};
var supportLang = ["kotlin", "go", "rust"];
function resolveLang(lang) {
  return lang ? langAlias[lang] || lang : "";
}
function resolveCode(el) {
  const clone = el.cloneNode(true);
  clone.querySelectorAll(ignoredNodes.join(",")).forEach((node) => node.remove());
  return clone.textContent || "";
}
function resolveCodeInfo(el) {
  const wrapper = el.querySelector("div[class*=language-]");
  const lang = wrapper?.className.match(RE_LANGUAGE)?.[1];
  const codeEl = wrapper?.querySelector("pre");
  let code = "";
  if (codeEl)
    code = resolveCode(codeEl);
  return { lang: resolveLang(lang), code };
}
function useCodeRepl(el) {
  const lang = ref();
  const loaded = ref(true);
  const firstRun = ref(true);
  const finished = ref(true);
  const stdout = ref([]);
  const stderr = ref([]);
  const error = ref("");
  const backendVersion = ref("");
  onMounted(() => {
    if (el.value) {
      const info = resolveCodeInfo(el.value);
      lang.value = info.lang;
    }
  });
  const executeMap = {
    kotlin: executeKotlin,
    go: executeGolang,
    rust: executeRust
  };
  function onCleanRun() {
    loaded.value = false;
    finished.value = false;
    stdout.value = [];
    stderr.value = [];
    error.value = "";
    firstRun.value = true;
    backendVersion.value = "";
  }
  async function onRunCode() {
    if (!el.value || !loaded.value)
      return;
    const info = resolveCodeInfo(el.value);
    lang.value = info.lang;
    if (!lang.value || !info.code || !supportLang.includes(lang.value))
      return;
    if (firstRun.value)
      firstRun.value = false;
    loaded.value = false;
    finished.value = false;
    stdout.value = [];
    stderr.value = [];
    error.value = "";
    await executeMap[lang.value]?.(info.code);
  }
  async function executeGolang(code) {
    const res = await http.post(api.go, { code });
    backendVersion.value = `v${res.version}`;
    loaded.value = true;
    if (res.error) {
      error.value = res.error;
      finished.value = true;
      return;
    }
    const events = res.events || [];
    for (const event of events) {
      if (event.kind === "stdout") {
        if (event.delay)
          await sleep(event.delay / 1e6);
        stdout.value.push(event.message);
      } else if (event.kind === "stderr") {
        stderr.value.push(event.message);
      }
    }
    finished.value = true;
  }
  async function executeKotlin(code) {
    const filename = "File.kt";
    const res = await http.post(api.kotlin, {
      args: "",
      files: [{ name: filename, publicId: "", text: code }]
    });
    backendVersion.value = `v${res.version}`;
    loaded.value = true;
    if (res.errors) {
      const errors = Array.isArray(res.errors[filename]) ? res.errors[filename] : [res.errors[filename]];
      if (errors.length) {
        errors.forEach(
          ({ message, severity }) => severity === "ERROR" && stderr.value.push(message)
        );
      }
    }
    stdout.value.push(res.text);
    finished.value = true;
  }
  async function executeRust(code) {
    await rustExecute(code, {
      onBegin: () => {
        loaded.value = true;
        finished.value = false;
        stdout.value = [];
        stderr.value = [];
        error.value = "";
        backendVersion.value = "release";
      },
      onError(message) {
        error.value = message;
      },
      onStdout(message) {
        stdout.value.push(message);
      },
      onStderr(message) {
        stderr.value.push(message);
      },
      onEnd: () => {
        finished.value = true;
      }
    });
  }
  return {
    onRunCode,
    onCleanRun,
    lang,
    backendVersion,
    firstRun,
    stderr,
    stdout,
    loaded,
    finished,
    error
  };
}
export {
  resolveCode,
  resolveCodeInfo,
  useCodeRepl
};
