#!/usr/bin/env node
import path from 'node:path';
import c from 'chalk';
import createCli from 'cac';
import { emitter, PresetError, applyPreset } from '@preset/core';
import * as readline from 'node:readline';
import makeDebugger from 'debug';
import { createLogUpdate } from 'log-update';
import { beep, cursor } from 'sisteransi';
import semver from 'semver';
import checkUpdates from 'update-notifier';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const version$1 = "0.11.3";

const patches = {
  help: {
    description: "Display this help message."
  },
  version: {
    description: "Display the version number."
  }
};
function patch(cli) {
  cli.globalCommand.options.forEach((option) => {
    if (Reflect.has(patches, option.name)) {
      Object.entries(Reflect.get(patches, option.name)).forEach(([key, value]) => Reflect.set(option, key, value));
    }
  });
  return cli;
}

const contexts = [];

function makeReporter(renderer) {
  return renderer;
}

const debug = {
  cli: makeDebugger("preset:cli")
};
function time(start, end) {
  const time2 = end - start;
  if (time2 > 1e3) {
    return `${(time2 / 1e3).toFixed(2)}s`;
  }
  return `${Math.round(time2)}ms`;
}
function formatResult(...parts) {
  const text = parts.filter((part) => part.count > 0 || !part.excludeWhenEmpty).map((part) => part.color(`${part.count} ${part.text}`)).join(" | ");
  const count = parts.reduce((total, { count: count2 }) => total + count2, 0);
  const displayCount = parts.filter((part) => part.count > 0 || !part.excludeWhenEmpty).some((part) => part.count !== count);
  return `${text} ${displayCount ? c.gray(`(${count})`) : ""}`;
}
async function invoke(fn, handleError) {
  try {
    return await fn();
  } catch (error) {
    handleError(error);
  }
}

const name = "@preset/core";
const version = "0.11.3";
const description = "Elegant, ecosystem-agnostic preset mechanism";
const license = "MIT";
const repository = {
	type: "git",
	url: "git+https://github.com/preset/preset.git",
	directory: "packages/core"
};
const author = "Enzo Innocenzi";
const publishConfig = {
	access: "public"
};
const files = [
	"dist",
	"*.d.ts"
];
const exports = {
	".": {
		"import": "./dist/index.mjs",
		require: "./dist/index.cjs"
	},
	"./*": "./*",
	"./globals": {
		types: "./globals.d.ts"
	}
};
const main = "dist/index.cjs";
const module = "dist/index.mjs";
const types = "dist/index.d.ts";
const bugs = "https://github.com/preset/preset/issues";
const homepage = "https://preset.dev";
const scripts = {
	build: "unbuild",
	stub: "unbuild --stub",
	test: "vitest",
	"test:watch": "vitest",
	prepublishOnly: "npm run build",
	prepublish: "tsx ./update-globals.ts",
	postpublish: "tsx ./update-globals.ts --delete"
};
const dependencies = {
	cac: "^6.7.14",
	debug: "^4.3.4",
	deepmerge: "^4.3.1",
	esbuild: "^0.20.2",
	"fast-glob": "^3.3.2",
	"fs-extra": "^11.2.0",
	mitt: "^3.0.1",
	"simple-git": "^3.24.0",
	"type-fest": "^4.17.0",
	unconfig: "^0.3.13",
	"unset-value": "^2.0.1"
};
const devDependencies = {
	"@types/debug": "^4.1.12",
	"@types/fs-extra": "^11.0.4",
	"detect-indent": "^7.0.1",
	execa: "^8.0.1",
	typescript: "^5.4.5"
};
const pkg = {
	name: name,
	version: version,
	description: description,
	license: license,
	repository: repository,
	author: author,
	publishConfig: publishConfig,
	files: files,
	exports: exports,
	main: main,
	module: module,
	types: types,
	bugs: bugs,
	homepage: homepage,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies
};

const checks = {
  current: pkg.version,
  versionMismatches: []
};
function registerVersionMismatches() {
  emitter.on("preset:resolve", (preset) => {
    if (!preset.presetVersion) {
      return;
    }
    if (!semver.satisfies(checks.current, preset.presetVersion)) {
      const requiredVersion = semver.coerce(preset.presetVersion)?.version;
      checks.versionMismatches.push({
        ...preset,
        isOutdated: requiredVersion ? semver.lt(requiredVersion, checks.current) : false
      });
    }
  });
}
async function checkLatestVersion() {
  const notifier = checkUpdates({
    pkg: {
      name: pkg.name,
      version: pkg.version
    },
    updateCheckInterval: 1e3 * 60 * 60 * 1
    // 1 hour
  });
  checks.updates = notifier.update;
}

const symbols = {
  spinner: ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"],
  arrow: "\u279C",
  check: "\u2713",
  cross: "\xD7",
  subArrow: " \u21AA ",
  pointerDouble: "\xBB",
  pointerSmall: "\u203A"
};

const format = {
  indent: (indent) => `${"  ".repeat(indent)}  `,
  dim: (text) => c.gray(text),
  highlight: (text) => c.bold(`${text}`),
  titleWorking: (text) => c.bgYellowBright.white.bold(`${text}`),
  titleFail: (text) => c.bgRed.white.bold(`${text}`),
  titleSuccess: (text) => c.bgGreen.white.bold(`${text}`),
  titleNextSteps: (text) => c.bgMagenta.white.bold(`${text}`),
  titleWarning: (text) => c.bgYellow.white.bold(`${text}`),
  promptHint: (text) => c.bold.gray(`${text}`),
  selectedChoice: (text) => c.cyan.underline(`${text}`),
  textPromptResponse: (text) => c.gray.bold(`${text}`)
};

function renderTextPrompt(preset, action, input) {
  let text = "\n";
  text += format.indent(preset.count + 1);
  text += `${format.dim(`${symbols.subArrow} ${action.options.text}`)} `;
  text += c.gray.bold(input?.response.trim() || action.options.default);
  return text;
}

function getChoicePrefix(preset, idx, cursor) {
  return format.indent(preset.count + 2) + (cursor === idx ? `${symbols.pointerDouble}` : " ");
}
function renderChoices(preset, input) {
  let outputText = "\n";
  for (let i = 0; i < input.choices.length; i++) {
    const choice = input.choices[i];
    const choiceTitle = typeof choice === "string" ? choice : choice.title;
    const title = input.cursor === i ? c.cyan.underline(choiceTitle) : choiceTitle;
    const prefix = getChoicePrefix(preset, i, input.cursor);
    outputText += `${prefix} ${title}
`;
  }
  return outputText;
}
function renderSelectPrompt(preset, action, input) {
  const isDone = input.isDone;
  const hasHint = Boolean(action.options.text);
  const outputTexts = [
    isDone ? symbols.pointerSmall : hasHint ? c.bold.gray(symbols.pointerSmall) : null,
    isDone ? input.response.trim() : hasHint ? c.bold.gray(action.options.text) : null
  ].filter((t) => t);
  const outputText = outputTexts.join(" ");
  return `${outputTexts.length ? " " : ""}${isDone ? outputText : outputText + renderChoices(preset, input)}`;
}

function renderPrompt(preset, action, inputs) {
  const input = inputs.find((input2) => input2.actionContextId === action.id);
  if (!input) {
    return "";
  }
  return input.isSelect ? renderSelectPrompt(preset, action, input) : renderTextPrompt(preset, action, input);
}

const listReporter = makeReporter({
  name: "list",
  registerEvents: () => {
    makeDebugger.disable();
    const inputs = [];
    const updateLog = createLogUpdate(process.stdout);
    const failedPresets = /* @__PURE__ */ new Set([]);
    let rl;
    let timer;
    let index = 0;
    function render() {
      let text = "";
      index = ++index % symbols.spinner.length;
      const symbol = {
        applying: c.yellowBright.bold(symbols.spinner[index]),
        applied: c.green.bold(symbols.check),
        failed: c.red.bold(symbols.cross)
      };
      const main = contexts.at(0);
      if (checks.versionMismatches.length || checks.updates) {
        const updateAvailable = checks.updates && checks.updates.latest !== checks.updates.current;
        text += "\n";
        text += ` ${format.titleWarning(updateAvailable ? " UPDATE AVAILABLE " : " VERSION MISMATCH ")}`;
        text += "\n\n";
        if (updateAvailable) {
          text += `  ${c.greenBright(symbols.arrow)}  Latest version: ${c.bold.greenBright(`v${checks.updates.latest}`)}
`;
          text += `  ${c.redBright(symbols.arrow)}  Current version: ${c.bold.redBright(`v${checks.updates.current}`)}
`;
        } else {
          text += `  ${c.greenBright(symbols.arrow)}  Current version: ${c.bold.greenBright(`v${checks.current}`)} ${c.gray("(latest)")}
`;
        }
        checks.versionMismatches.forEach((mismatch) => {
          const name = contexts.find((preset) => mismatch.presetFile === preset.localPreset.presetFile)?.name;
          if (name) {
            text += `  ${c.redBright(symbols.arrow)}  Preset ${c.magenta(name)} requires ${c.bold.redBright(mismatch.presetVersion)} ${mismatch.isOutdated ? c.gray("(outdated, may not work)") : ""}
`;
          }
        });
        if (updateAvailable) {
          text += `  ${c.greenBright(symbols.arrow)}  ${c.bold(`Use ${c.magenta.bold("npm i -g @preset/cli")} to update.`)}
`;
        }
        text += "\n";
      }
      text += "\n";
      text += {
        applying: ` ${format.titleWorking(" RUN ")} ${format.dim(`Applying ${format.highlight(main.name)}...`)}`,
        applied: ` ${format.titleSuccess(" OK ")} ${c.green(`Applied ${format.highlight(main.name)}.`)}`,
        failed: ` ${format.titleFail(" ERROR ")} ${c.red(`Failed applying ${format.highlight(main.name)}.`)}`
      }[main.status];
      text += "\n\n";
      function renderPresetActions(preset) {
        if (!preset) {
          return;
        }
        preset.actions.filter((action) => !action.groupContextId).forEach((action) => {
          text += format.indent(preset.count);
          text += symbol[action.status];
          text += `  ${{ applying: "Executing", applied: "Executed", failed: "Failed" }[action.status]} action: `;
          text += format.highlight(c.white(action.options.title || action.name));
          if (action.name === "apply-nested-preset") {
            const nestedPresetContext = contexts.find(({ applyOptions }) => applyOptions.actionContextId === action.id);
            if (nestedPresetContext) {
              text += format.dim(` (preset: ${format.highlight(nestedPresetContext?.name)})`);
              if (nestedPresetContext?.error) {
                nestedPresetContext.error.message.split("\n").forEach((line, index2) => {
                  text += "\n";
                  text += format.indent(preset.count + 1);
                  text += c.red(`${index2 === 0 ? symbols.subArrow : " "} ${line}`);
                });
              }
              text += "\n";
            }
            renderPresetActions(nestedPresetContext);
          }
          if (action.name === "install-packages") {
            text += format.dim(` (${format.highlight(action.options.for)})`);
          }
          if (action.end && preset.options.time) {
            text += format.dim(`  (${time(action.start, action.end)})`);
          }
          if (action.name === "group") {
            const children = preset.actions.filter((child) => child.groupContextId === action.id);
            const failed = children.filter((child) => child.status === "failed");
            const logs = children.filter((child) => child.status === "applying").flatMap((action2) => action2.log);
            if (children.length > 1) {
              text += format.dim(` (${children.length} actions)`);
            }
            if (logs.length > 0 && action.status === "applying") {
              text += "\n";
              text += format.indent(preset.count + 1);
              text += format.dim(`${symbols.subArrow} ${logs.at(-1) ?? "..."}`);
            }
            if (failed.length) {
              failed.forEach((failedChild) => {
                if (failedChild?.error) {
                  failedChild.error.message.split("\n").forEach((line, index2) => {
                    text += "\n";
                    text += format.indent(preset.count + 1);
                    text += c.red(`${index2 === 0 ? symbols.subArrow : " "} ${line}`);
                  });
                }
              });
            }
          }
          if (action.name === "prompt") {
            text += renderPrompt(preset, action, inputs);
          }
          if (action.log.length > 0 && action.status === "applying") {
            text += "\n";
            text += format.indent(preset.count + 1);
            text += format.dim(`${symbols.subArrow} ${action.log.at(-1) ?? "..."}`);
          }
          if (action.error && action.name !== "apply-nested-preset") {
            action.error.message.split("\n").forEach((line, index2) => {
              text += "\n";
              text += format.indent(preset.count + 1);
              text += c.red(`${index2 === 0 ? symbols.subArrow : " "} ${line}`);
            });
          }
          if (action.name !== "apply-nested-preset") {
            text += "\n";
          }
        });
      }
      renderPresetActions(main);
      if (contexts[0].status !== "applying") {
        const actionsFailed = contexts.reduce((failed, { actions }) => failed += actions.reduce((failed2, { status }) => failed2 += status === "failed" ? 1 : 0, 0), 0);
        const actionsSucceeded = contexts.reduce((succeeded, { actions }) => succeeded += actions.reduce((succeeded2, { status }) => succeeded2 += status === "applied" ? 1 : 0, 0), 0);
        const presetsFailed = contexts.reduce((failed, { status }) => failed += status === "failed" ? 1 : 0, 0);
        const presetsSucceeded = contexts.reduce((failed, { status }) => failed += status === "applied" ? 1 : 0, 0);
        text += "\n";
        text += ` ${c.gray("Presets")}  ${formatResult({
          count: presetsSucceeded,
          color: c.green.bold,
          text: "applied",
          excludeWhenEmpty: true
        }, {
          count: presetsFailed,
          color: c.green.red,
          text: "failed",
          excludeWhenEmpty: true
        })} 
`;
        text += ` ${c.gray("Actions")}  ${formatResult(
          {
            count: actionsSucceeded,
            color: c.green.bold,
            text: "executed"
          },
          {
            count: actionsFailed,
            color: c.green.red,
            text: "failed",
            excludeWhenEmpty: true
          }
        )} 
`;
        text += `${c.gray("Duration")}  ${time(contexts[0].start, contexts[0].end)}`;
        text += "\n";
        const hl = (text2) => c.magenta(text2);
        const b = (text2) => c.bold(text2);
        const postInstall = typeof contexts[0].preset.postInstall === "function" ? contexts[0].preset.postInstall({ context: contexts[0], hl, b }) : contexts[0].preset.postInstall;
        if (main.status === "failed") {
          failedPresets.add(main.id);
          text += "\n\n";
          text += ` ${format.titleFail(` ${main.error?.code ?? "ERROR"} `)} ${c.red(main.error?.parent?.message ?? main.error?.message ?? main.error?.details ?? "An unknown error occured.")}`;
          text += "\n";
        } else if (postInstall) {
          text += "\n\n";
          text += ` ${format.titleNextSteps(" NEXT STEPS ")}`;
          text += "\n\n";
          text += postInstall.map((msg) => `  ${c.magentaBright("\u279C")}  ${msg}`).join("\n");
          text += "\n";
        }
      }
      updateLog(text);
    }
    emitter.on("prompt:input", async (promptInput) => {
      inputs.push({ ...promptInput, response: "" });
      function onInput() {
        const input = inputs.at(-1);
        let chunk;
        while ((chunk = process.stdin.read()) !== null) {
          const currentBuffer = Buffer.from(chunk).toString().charCodeAt(0);
          if (currentBuffer === 127) {
            input.response = input.response.slice(0, -1);
            continue;
          } else if (currentBuffer === 3 || currentBuffer == 27) {
            process.exit();
          }
          input.response += chunk;
        }
        if (input.response.endsWith("\r") || input.response.endsWith(String.fromCharCode(3))) {
          input.response = input.response.slice(0, -1);
          process.stdin.off("readable", onInput);
          process.stdin.setRawMode(false);
          emitter.emit("prompt:response", {
            id: input.id,
            response: input.response
          });
        }
      }
      process.stdin.on("readable", onInput);
      process.stdin.setRawMode(true);
    });
    emitter.on("prompt:select", async (promptSelect) => {
      const { stdin, stdout } = process;
      const initialCursor = promptSelect.initial || 0;
      const choices = promptSelect.choices.map((ch) => ({
        title: typeof ch === "string" ? ch : ch.title,
        value: typeof ch === "string" ? ch : ch.value || ch.title
      }));
      const state = {
        cursor: initialCursor,
        response: choices[initialCursor].value,
        isDone: false
      };
      inputs.push({ ...promptSelect, ...state });
      function updateInput(actionContextId, state2) {
        const idx = inputs.findIndex((input) => input.actionContextId === actionContextId);
        const currentInput = inputs[idx];
        currentInput.cursor = state2.cursor;
        currentInput.response = state2.response;
        currentInput.isDone = state2.isDone;
      }
      function moveSelectPromptSelection(n) {
        state.cursor = n;
        state.response = choices[n].value;
        updateInput(promptSelect.actionContextId, state);
      }
      const actionKeys = {
        return: "submit",
        enter: "submit",
        up: "up",
        down: "down",
        escape: "cancel"
      };
      const actions = {
        up: () => {
          if (state.cursor === 0) {
            moveSelectPromptSelection(choices.length - 1);
          } else {
            moveSelectPromptSelection(state.cursor - 1);
          }
        },
        down: () => {
          if (state.cursor === choices.length - 1) {
            moveSelectPromptSelection(0);
          } else {
            moveSelectPromptSelection(state.cursor + 1);
          }
        },
        cancel: () => {
          process.exit();
        },
        submit: () => {
          state.isDone = true;
          updateInput(promptSelect.actionContextId, state);
          finishSelectPrompt();
        }
      };
      function handleKeypress(str, key) {
        const actionKey = actionKeys[key.name];
        const action = actions[actionKey];
        if (key.name === "c" && key.ctrl) {
          process.exit();
        } else if (typeof action === "function") {
          action();
        } else {
          stdout.write(beep);
        }
      }
      function finishSelectPrompt() {
        const input = inputs.at(-1);
        stdout.write(cursor.show);
        stdin.removeListener("keypress", handleKeypress);
        if (stdin.isTTY) {
          stdin.setRawMode(false);
        }
        emitter.emit("prompt:response", {
          id: input.id,
          response: input.response
        });
      }
      if (stdin.isTTY) {
        stdin.setRawMode(true);
      }
      stdin.on("keypress", handleKeypress);
    });
    emitter.on("preset:start", (context) => {
      contexts.push(context);
      render();
      if (context.count === 0) {
        context.applyOptions.parsedOptions.interaction = context.applyOptions.parsedOptions.interaction === void 0 ? true : context.applyOptions.parsedOptions.interaction;
        if (timer) {
          clearInterval(timer);
        }
        rl = readline.createInterface({ input: process.stdin, escapeCodeTimeout: 50 });
        readline.emitKeypressEvents(process.stdin, rl);
        timer = setInterval(() => render(), 150);
      }
    });
    emitter.on("preset:end", (context) => {
      if (context.count === 0) {
        setTimeout(() => {
          render();
          clearInterval(timer);
          rl?.close();
          if (failedPresets.size > 0) {
            process.exit(1);
          }
        }, 1);
      }
    });
  }
});

const debugReporter = makeReporter({
  name: "debug",
  registerEvents: () => {
    makeDebugger.enable("preset:*");
    const failedPresets = /* @__PURE__ */ new Set([]);
    emitter.on("preset:end", (context) => {
      if (context.status === "failed") {
        failedPresets.add(context.id);
      }
      if (context.count === 0 && failedPresets.size > 0) {
        process.exit(1);
      }
    });
  }
});

const reporters = {
  list: listReporter,
  debug: debugReporter
};

invoke(async () => {
  debug.cli(`Running preset v${version$1}`);
  registerVersionMismatches();
  checkLatestVersion();
  const cli = createCli("preset").option("--no-interaction", "Disable interactions. Prompts will use their default answers.").option("--time", "Display the duration for each action.").option("--debug", "Use the debug reporter.").option("--silent", "Do not use a reporter.").help().version(version$1);
  cli.command("<resolvable> [target-directory]", "Applies the given preset.").alias("apply").option("-p, --path [path]", "The path to a sub-directory in which to look for a preset.").option("-t, --tag [tag]", "The branch or tag to use if the preset is a repository.").option("--ssh", "Whether to use SSH or not. This can be determined depending on the URL of the Git repository, defaulting to false.").allowUnknownOptions().action(async (resolvable, targetDirectory, parsedOptions) => await applyPreset({
    parsedOptions,
    resolvable,
    targetDirectory: targetDirectory ? path.resolve(targetDirectory) : process.cwd(),
    rawArguments: process.argv.slice(2)
  }));
  cli.command("init [target-directory]", "Initializes a new preset.").alias("initialize").option("--no-git", "Do not initialize a Git repository.").option("--no-install", "Do not install the preset dependency.").allowUnknownOptions().action(async (targetDirectory, parsedOptions) => await applyPreset({
    parsedOptions,
    resolvable: path.resolve(__dirname, "../init"),
    targetDirectory: targetDirectory ?? process.cwd(),
    rawArguments: process.argv.slice(2)
  }));
  const { options } = patch(cli).parse(process.argv, { run: false });
  debug.cli("Parsed options:", options);
  if (process.env.CI || options.debug === true) {
    reporters.debug.registerEvents();
  } else if (!options.silent) {
    Reflect.get(reporters, options.reporter || "list")?.registerEvents();
  }
  await cli.runMatchedCommand();
}, (error) => {
  if (error instanceof PresetError) {
    console.log();
    console.log(`${c.bgRed.white.bold(` ${error.code} `)} ${c.red(error.details ?? error.parent?.message)}`);
    console.log();
  } else {
    console.log();
    console.log(`${c.bgRed.white.bold(" ERROR ")} ${c.red(error.message)}`);
    console.log();
  }
  process.exit(1);
});
