{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItUMLOptions } from \"./options.js\";\n\nexport const uml: PluginWithOptions<MarkdownItUMLOptions> = (\n  md,\n  { name, open, close, render } = {\n    name: \"uml\",\n    open: \"start\",\n    close: \"end\",\n    render: (tokens, index): string => {\n      const token = tokens[index];\n      const { content, info, type } = token;\n\n      return `<div class=\"${type}\" title=\"${info}\">${content}</div>`;\n    },\n  },\n) => {\n  const OPEN_MARKER = `@${open}`;\n  const CLOSE_MARKER = `@${close}`;\n\n  const umlRule: RuleBlock = (state, startLine, endLine, silent) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    /*\n     * Check out the first character quickly,\n     * this should filter out most of non-uml blocks\n     */\n    if (state.src.charAt(start) !== \"@\") return false;\n\n    let index;\n\n    // Check out the rest of the marker string\n    for (index = 0; index < OPEN_MARKER.length; ++index)\n      if (OPEN_MARKER[index] !== state.src[start + index]) return false;\n\n    const markup = state.src.slice(start, start + index);\n    const params = state.src.slice(start + index, max);\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let autoClosed = false;\n    let nextLine = startLine;\n\n    // Search for the end of the block\n    while (\n      /*\n       * unclosed block should be auto closed by end of document.\n       * also block seems to be auto closed by end of parent\n       */\n      nextLine < endLine\n    ) {\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        /*\n         * non-empty line with negative indent should stop the list:\n         * - ```\n         *  test\n         */\n        break;\n\n      if (\n        // didnâ€™t find the closing fence\n        state.src.charAt(start) === \"@\" &&\n        // closing fence should not be indented with respect of opening fence\n        state.sCount[nextLine] <= state.sCount[startLine]\n      ) {\n        let closeMarkerMatched = true;\n\n        for (index = 0; index < CLOSE_MARKER.length; ++index)\n          if (CLOSE_MARKER[index] !== state.src[start + index]) {\n            closeMarkerMatched = false;\n            break;\n          }\n\n        if (\n          closeMarkerMatched &&\n          // make sure tail has spaces only\n          state.skipSpaces(start + index) >= max\n        ) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n\n      nextLine++;\n    }\n\n    const contents = state.src\n      .split(\"\\n\")\n      .slice(startLine + 1, nextLine)\n      .join(\"\\n\");\n\n    const umlToken = state.push(name, \"uml\", 0);\n\n    umlToken.block = true;\n    umlToken.info = params;\n    umlToken.content = contents;\n    umlToken.map = [startLine, nextLine];\n    umlToken.markup = markup;\n\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", name, umlRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[name] = render;\n};\n"],"names":["uml","md","name","open","close","render","tokens","index","token","content","info","type","OPEN_MARKER","CLOSE_MARKER","umlRule","state","startLine","endLine","silent","start","max","markup","params","autoClosed","nextLine","closeMarkerMatched","contents","umlToken"],"mappings":"AAKa,MAAAA,EAA+C,CAC1DC,EACA,CAAE,KAAAC,EAAM,KAAAC,EAAM,MAAAC,EAAO,OAAAC,CAAO,EAAI,CAC9B,KAAM,MACN,KAAM,QACN,MAAO,MACP,OAAQ,CAACC,EAAQC,IAAkB,CACjC,MAAMC,EAAQF,EAAOC,CAAK,EACpB,CAAE,QAAAE,EAAS,KAAAC,EAAM,KAAAC,CAAK,EAAIH,EAEhC,MAAO,eAAeG,CAAI,YAAYD,CAAI,KAAKD,CAAO,QACxD,CACF,IACG,CACH,MAAMG,EAAc,IAAIT,CAAI,GACtBU,EAAe,IAAIT,CAAK,GAExBU,EAAqB,CAACC,EAAOC,EAAWC,EAASC,IAAW,CAChE,IAAIC,EAAQJ,EAAM,OAAOC,CAAS,EAAID,EAAM,OAAOC,CAAS,EACxDI,EAAML,EAAM,OAAOC,CAAS,EAMhC,GAAID,EAAM,IAAI,OAAOI,CAAK,IAAM,IAAK,MAAO,GAE5C,IAAIZ,EAGJ,IAAKA,EAAQ,EAAGA,EAAQK,EAAY,OAAQ,EAAEL,EAC5C,GAAIK,EAAYL,CAAK,IAAMQ,EAAM,IAAII,EAAQZ,CAAK,EAAG,MAAO,GAE9D,MAAMc,EAASN,EAAM,IAAI,MAAMI,EAAOA,EAAQZ,CAAK,EAC7Ce,EAASP,EAAM,IAAI,MAAMI,EAAQZ,EAAOa,CAAG,EAGjD,GAAIF,EAAQ,MAAO,GAEnB,IAAIK,EAAa,GACbC,EAAWR,EAGf,KAKEQ,EAAWP,IAEXE,EAAQJ,EAAM,OAAOS,CAAQ,EAAIT,EAAM,OAAOS,CAAQ,EACtDJ,EAAML,EAAM,OAAOS,CAAQ,EAEvB,EAAAL,EAAQC,GAAOL,EAAM,OAAOS,CAAQ,EAAIT,EAAM,aAJlD,CAYA,GAEEA,EAAM,IAAI,OAAOI,CAAK,IAAM,KAE5BJ,EAAM,OAAOS,CAAQ,GAAKT,EAAM,OAAOC,CAAS,EAChD,CACA,IAAIS,EAAqB,GAEzB,IAAKlB,EAAQ,EAAGA,EAAQM,EAAa,OAAQ,EAAEN,EAC7C,GAAIM,EAAaN,CAAK,IAAMQ,EAAM,IAAII,EAAQZ,CAAK,EAAG,CACpDkB,EAAqB,GACrB,KACF,CAEF,GACEA,GAEAV,EAAM,WAAWI,EAAQZ,CAAK,GAAKa,EACnC,CAEAG,EAAa,GACb,KACF,CACF,CAEAC,GACF,CAEA,MAAME,EAAWX,EAAM,IACpB,MAAM;AAAA,CAAI,EACV,MAAMC,EAAY,EAAGQ,CAAQ,EAC7B,KAAK;AAAA,CAAI,EAENG,EAAWZ,EAAM,KAAKb,EAAM,MAAO,CAAC,EAE1C,OAAAyB,EAAS,MAAQ,GACjBA,EAAS,KAAOL,EAChBK,EAAS,QAAUD,EACnBC,EAAS,IAAM,CAACX,EAAWQ,CAAQ,EACnCG,EAAS,OAASN,EAElBN,EAAM,KAAOS,GAAYD,EAAa,EAAI,GAEnC,EACT,EAEAtB,EAAG,MAAM,MAAM,OAAO,QAASC,EAAMY,EAAS,CAC5C,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,CAAC,EAEDb,EAAG,SAAS,MAAMC,CAAI,EAAIG,CAC5B"}