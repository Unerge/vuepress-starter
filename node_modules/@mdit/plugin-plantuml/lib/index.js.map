{"version":3,"file":"index.js","sources":["../src/lib/deflate.js","../src/plugin.ts"],"sourcesContent":["/** eslint-disable */\n/** prettier-ignore */\n// Using this library so that our img links are compatible with plantUml website.\n// TODO: replace this library with zlib once we create our private uml server.\n\n\"use strict\";\n\n// Original[some parts modified to avoid errors]:\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = zip_deflate(src);\n */\n\n/* constant parameters */\nvar zip_WSIZE = 32768; // Sliding Window size\nvar zip_STORED_BLOCK = 0;\nvar zip_STATIC_TREES = 1;\nvar zip_DYN_TREES = 2;\n\n/* for deflate */\nvar zip_DEFAULT_LEVEL = 6;\nvar zip_FULL_SEARCH = true;\nvar zip_INBUFSIZ = 32768; // Input buffer size\nvar zip_INBUF_EXTRA = 64; // Extra buffer\nvar zip_OUTBUFSIZ = 1024 * 8;\nvar zip_window_size = 2 * zip_WSIZE;\nvar zip_MIN_MATCH = 3;\nvar zip_MAX_MATCH = 258;\nvar zip_BITS = 16;\n// for SMALL_MEM\nvar zip_LIT_BUFSIZE = 0x2000;\nvar zip_HASH_BITS = 13;\n// for MEDIUM_MEM\n// var zip_LIT_BUFSIZE = 0x4000;\n// var zip_HASH_BITS = 14;\n// for BIG_MEM\n// var zip_LIT_BUFSIZE = 0x8000;\n// var zip_HASH_BITS = 15;\n// if (zip_LIT_BUFSIZE > zip_INBUFSIZ) { alert('error: zip_INBUFSIZ is too small'); }\n// if ((zip_WSIZE << 1) > (1 << zip_BITS)) { alert('error: zip_WSIZE is too large'); }\n// if (zip_HASH_BITS > zip_BITS - 1) { alert('error: zip_HASH_BITS is too large'); }\n// if (zip_HASH_BITS < 8 || zip_MAX_MATCH != 258) { alert('error: Code too clever'); }\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\nvar zip_WMASK = zip_WSIZE - 1;\nvar zip_NIL = 0; // Tail of hash chains\nvar zip_TOO_FAR = 4096;\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\nvar zip_SMALLEST = 1;\nvar zip_MAX_BITS = 15;\nvar zip_MAX_BL_BITS = 7;\nvar zip_LENGTH_CODES = 29;\nvar zip_LITERALS = 256;\nvar zip_END_BLOCK = 256;\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\nvar zip_D_CODES = 30;\nvar zip_BL_CODES = 19;\nvar zip_REP_3_6 = 16;\nvar zip_REPZ_3_10 = 17;\nvar zip_REPZ_11_138 = 18;\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) / zip_MIN_MATCH);\n\n/* variables */\nvar zip_free_queue;\nvar zip_qhead, zip_qtail;\nvar zip_initflag;\nvar zip_outbuf = null;\nvar zip_outcnt, zip_outoff;\nvar zip_complete;\nvar zip_window;\nvar zip_d_buf;\nvar zip_l_buf;\nvar zip_prev;\nvar zip_bi_buf;\nvar zip_bi_valid;\nvar zip_block_start;\nvar zip_ins_h;\nvar zip_hash_head;\nvar zip_prev_match;\nvar zip_match_available;\nvar zip_match_length;\nvar zip_prev_length;\nvar zip_strstart;\nvar zip_match_start;\nvar zip_eofile;\nvar zip_lookahead;\nvar zip_max_chain_length;\nvar zip_max_lazy_match;\nvar zip_compr_level;\nvar zip_good_match;\nvar zip_nice_match;\nvar zip_dyn_ltree;\nvar zip_dyn_dtree;\nvar zip_static_ltree;\nvar zip_static_dtree;\nvar zip_bl_tree;\nvar zip_l_desc;\nvar zip_d_desc;\nvar zip_bl_desc;\nvar zip_bl_count;\nvar zip_heap;\nvar zip_heap_len;\nvar zip_heap_max;\nvar zip_depth;\nvar zip_length_code;\nvar zip_dist_code;\nvar zip_base_length;\nvar zip_base_dist;\nvar zip_flag_buf;\nvar zip_last_lit;\nvar zip_last_dist;\nvar zip_last_flags;\nvar zip_flags;\nvar zip_flag_bit;\nvar zip_opt_len;\nvar zip_static_len;\nvar zip_deflate_data;\nvar zip_deflate_pos;\n\n/* constant tables */\nvar zip_extra_lbits = [\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0,\n];\nvar zip_extra_dbits = [\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13,\n];\nvar zip_extra_blbits = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,\n];\nvar zip_bl_order = [\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\n];\nvar zip_configuration_table = [\n  new zip_DeflateConfiguration(0, 0, 0, 0),\n  new zip_DeflateConfiguration(4, 4, 8, 4),\n  new zip_DeflateConfiguration(4, 5, 16, 8),\n  new zip_DeflateConfiguration(4, 6, 32, 32),\n  new zip_DeflateConfiguration(4, 4, 16, 16),\n  new zip_DeflateConfiguration(8, 16, 32, 32),\n  new zip_DeflateConfiguration(8, 16, 128, 128),\n  new zip_DeflateConfiguration(8, 32, 128, 256),\n  new zip_DeflateConfiguration(32, 128, 258, 1024),\n  new zip_DeflateConfiguration(32, 258, 258, 4096),\n];\n\n/* objects (deflate) */\n\nfunction zip_DeflateCT() {\n  this.fc = 0; // frequency count or bit string\n  this.dl = 0; // father node in Huffman tree or length of bit string\n}\n\nfunction zip_DeflateTreeDesc() {\n  this.dyn_tree = null; // the dynamic tree\n  this.static_tree = null; // corresponding static tree or NULL\n  this.extra_bits = null; // extra bits for each code or NULL\n  this.extra_base = 0; // base index for extra_bits\n  this.elems = 0; // max number of elements in the tree\n  this.max_length = 0; // max bit length for the codes\n  this.max_code = 0; // largest code with non zero frequency\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction zip_DeflateConfiguration(a, b, c, d) {\n  this.good_length = a; // reduce lazy search above this match length\n  this.max_lazy = b; // do not perform lazy search above this match length\n  this.nice_length = c; // quit search above this match length\n  this.max_chain = d;\n}\n\nfunction zip_DeflateBuffer() {\n  this.next = null;\n  this.len = 0;\n  this.ptr = new Array(zip_OUTBUFSIZ);\n  this.off = 0;\n}\n\n/* routines (deflate) */\n\nfunction zip_deflate_start(level) {\n  var i;\n\n  if (!level) {\n    level = zip_DEFAULT_LEVEL;\n  } else if (level < 1) {\n    level = 1;\n  } else if (level > 9) {\n    level = 9;\n  }\n\n  zip_compr_level = level;\n  zip_initflag = false;\n  zip_eofile = false;\n  if (zip_outbuf != null) {\n    return;\n  }\n\n  zip_free_queue = zip_qhead = zip_qtail = null;\n  zip_outbuf = new Array(zip_OUTBUFSIZ);\n  zip_window = new Array(zip_window_size);\n  zip_d_buf = new Array(zip_DIST_BUFSIZE);\n  zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n  zip_prev = new Array(1 << zip_BITS);\n  zip_dyn_ltree = new Array(zip_HEAP_SIZE);\n  for (i = 0; i < zip_HEAP_SIZE; i++) {\n    zip_dyn_ltree[i] = new zip_DeflateCT();\n  }\n  zip_dyn_dtree = new Array(2 * zip_D_CODES + 1);\n  for (i = 0; i < 2 * zip_D_CODES + 1; i++) {\n    zip_dyn_dtree[i] = new zip_DeflateCT();\n  }\n  zip_static_ltree = new Array(zip_L_CODES + 2);\n  for (i = 0; i < zip_L_CODES + 2; i++) {\n    zip_static_ltree[i] = new zip_DeflateCT();\n  }\n  zip_static_dtree = new Array(zip_D_CODES);\n  for (i = 0; i < zip_D_CODES; i++) {\n    zip_static_dtree[i] = new zip_DeflateCT();\n  }\n  zip_bl_tree = new Array(2 * zip_BL_CODES + 1);\n  for (i = 0; i < 2 * zip_BL_CODES + 1; i++) {\n    zip_bl_tree[i] = new zip_DeflateCT();\n  }\n  zip_l_desc = new zip_DeflateTreeDesc();\n  zip_d_desc = new zip_DeflateTreeDesc();\n  zip_bl_desc = new zip_DeflateTreeDesc();\n  zip_bl_count = new Array(zip_MAX_BITS + 1);\n  zip_heap = new Array(2 * zip_L_CODES + 1);\n  zip_depth = new Array(2 * zip_L_CODES + 1);\n  zip_length_code = new Array(zip_MAX_MATCH - zip_MIN_MATCH + 1);\n  zip_dist_code = new Array(512);\n  zip_base_length = new Array(zip_LENGTH_CODES);\n  zip_base_dist = new Array(zip_D_CODES);\n  zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n}\n\nfunction zip_reuse_queue(p) {\n  p.next = zip_free_queue;\n  zip_free_queue = p;\n}\n\nfunction zip_new_queue() {\n  var p;\n\n  if (zip_free_queue != null) {\n    p = zip_free_queue;\n    zip_free_queue = zip_free_queue.next;\n  } else {\n    p = new zip_DeflateBuffer();\n  }\n  p.next = null;\n  p.len = p.off = 0;\n\n  return p;\n}\n\nfunction zip_head1(i) {\n  return zip_prev[zip_WSIZE + i];\n}\n\nfunction zip_head2(i, val) {\n  return (zip_prev[zip_WSIZE + i] = val);\n}\n\n/* put_byte is used for the compressed output, put_ubyte for the\n * uncompressed output. However unlzw() uses window for its\n * suffix table instead of its output buffer, so it does not use put_ubyte\n * (to be cleaned up).\n */\nfunction zip_put_byte(c) {\n  zip_outbuf[zip_outoff + zip_outcnt++] = c;\n  if (zip_outoff + zip_outcnt == zip_OUTBUFSIZ) {\n    zip_qoutbuf();\n  }\n}\n\n/* Output a 16 bit value, lsb first */\nfunction zip_put_short(w) {\n  w &= 0xffff;\n  if (zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n    zip_outbuf[zip_outoff + zip_outcnt++] = w & 0xff;\n    zip_outbuf[zip_outoff + zip_outcnt++] = w >>> 8;\n  } else {\n    zip_put_byte(w & 0xff);\n    zip_put_byte(w >>> 8);\n  }\n}\n\n/* ==========================================================================\n * Insert string s in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of s are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\nfunction zip_INSERT_STRING() {\n  zip_ins_h =\n    ((zip_ins_h << zip_H_SHIFT) ^\n      (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff)) &\n    zip_HASH_MASK;\n  zip_hash_head = zip_head1(zip_ins_h);\n  zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n  zip_head2(zip_ins_h, zip_strstart);\n}\n\n/* Send a code of the given tree. c and tree must not have side effects */\nfunction zip_SEND_CODE(c, tree) {\n  zip_send_bits(tree[c].fc, tree[c].dl);\n}\n\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. dist_code[256] and dist_code[257] are never\n * used.\n */\nfunction zip_D_CODE(dist) {\n  return (\n    (dist < 256 ? zip_dist_code[dist] : zip_dist_code[256 + (dist >> 7)]) & 0xff\n  );\n}\n\n/* ==========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction zip_SMALLER(tree, n, m) {\n  return (\n    tree[n].fc < tree[m].fc ||\n    (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m])\n  );\n}\n\n/* ==========================================================================\n * read string data\n */\nfunction zip_read_buff(buff, offset, n) {\n  var i;\n  for (i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++) {\n    buff[offset + i] = zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n  }\n\n  return i;\n}\n\n/* ==========================================================================\n * Initialize the \"longest match\" routines for a new file\n */\nfunction zip_lm_init() {\n  var j;\n\n  /* Initialize the hash table. */\n  for (\n    j = 0;\n    j < zip_HASH_SIZE;\n    j++ //\tzip_head2(j, zip_NIL);\n  ) {\n    zip_prev[zip_WSIZE + j] = 0;\n  }\n  /* prev will be initialized on the fly */\n\n  /* Set the default configuration parameters:\n   */\n  zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n  zip_good_match = zip_configuration_table[zip_compr_level].good_length;\n  if (!zip_FULL_SEARCH) {\n    zip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\n  }\n  zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n\n  zip_strstart = 0;\n  zip_block_start = 0;\n\n  zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n  if (zip_lookahead <= 0) {\n    zip_eofile = true;\n    zip_lookahead = 0;\n\n    return;\n  }\n  zip_eofile = false;\n  /* Make sure that we always have enough lookahead. This is important\n   * if input comes from a device such as a tty.\n   */\n  while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) {\n    zip_fill_window();\n  }\n\n  /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n   * not important since only literal bytes will be emitted.\n   */\n  zip_ins_h = 0;\n  for (j = 0; j < zip_MIN_MATCH - 1; j++) {\n    //      UPDATE_HASH(ins_h, window[j]);\n    zip_ins_h =\n      ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n  }\n}\n\n/* ==========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n */\nfunction zip_longest_match(cur_match) {\n  var chain_length = zip_max_chain_length; // max hash chain length\n  var scanp = zip_strstart; // current string\n  var matchp; // matched string\n  var len; // length of current match\n  var best_len = zip_prev_length; // best match length so far\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n  var limit =\n    zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL;\n\n  var strendp = zip_strstart + zip_MAX_MATCH;\n  var scan_end1 = zip_window[scanp + best_len - 1];\n  var scan_end = zip_window[scanp + best_len];\n\n  /* Do not waste too much time if we already have a good match: */\n  if (zip_prev_length >= zip_good_match) {\n    chain_length >>= 2;\n  }\n\n  //  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n  do {\n    //    Assert(cur_match < encoder->strstart, \"no future\");\n    matchp = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2:\n     */\n    if (\n      zip_window[matchp + best_len] != scan_end ||\n      zip_window[matchp + best_len - 1] != scan_end1 ||\n      zip_window[matchp] != zip_window[scanp] ||\n      zip_window[++matchp] != zip_window[scanp + 1]\n    ) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scanp += 2;\n    matchp++;\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      // nothing\n    } while (\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      scanp < strendp\n    );\n\n    len = zip_MAX_MATCH - (strendp - scanp);\n    scanp = strendp - zip_MAX_MATCH;\n\n    if (len > best_len) {\n      zip_match_start = cur_match;\n      best_len = len;\n      if (zip_FULL_SEARCH) {\n        if (len >= zip_MAX_MATCH) break;\n      } else if (len >= zip_nice_match) break;\n\n      scan_end1 = zip_window[scanp + best_len - 1];\n      scan_end = zip_window[scanp + best_len];\n    }\n  } while (\n    (cur_match = zip_prev[cur_match & zip_WMASK]) > limit &&\n    --chain_length != 0\n  );\n\n  return best_len;\n}\n\n/* ==========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead, and sets eofile if end of input file.\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n * OUT assertions: at least one byte has been read, or eofile is set;\n *    file reads are performed for at least two bytes (required for the\n *    translate_eol option).\n */\nfunction zip_fill_window() {\n  var n, m;\n\n  // Amount of free space at the end of the window.\n  var more = zip_window_size - zip_lookahead - zip_strstart;\n\n  /* If the window is almost full and there is insufficient lookahead,\n   * move the upper half to the lower one to make room in the upper half.\n   */\n  if (more == -1) {\n    /* Very unlikely, but possible on 16 bit machine if strstart == 0\n     * and lookahead == 1 (input done one byte at time)\n     */\n    more--;\n  } else if (zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n    /* By the IN assertion, the window is not empty so we can't confuse\n     * more == 0 with more == 64K on a 16 bit machine.\n     */\n    //\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n    //\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n    for (n = 0; n < zip_WSIZE; n++) {\n      zip_window[n] = zip_window[n + zip_WSIZE];\n    }\n\n    zip_match_start -= zip_WSIZE;\n    zip_strstart -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n    zip_block_start -= zip_WSIZE;\n\n    for (n = 0; n < zip_HASH_SIZE; n++) {\n      m = zip_head1(n);\n      zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n    }\n    for (n = 0; n < zip_WSIZE; n++) {\n      /* If n is not on any hash chain, prev[n] is garbage but\n       * its value will never be used.\n       */\n      m = zip_prev[n];\n      zip_prev[n] = m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL;\n    }\n    more += zip_WSIZE;\n  }\n  // At this point, more >= 2\n  if (!zip_eofile) {\n    n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n    if (n <= 0) {\n      zip_eofile = true;\n    } else {\n      zip_lookahead += n;\n    }\n  }\n}\n\n/* ==========================================================================\n * Processes a new input file and return its compressed length. This\n * function does not perform lazy evaluationof matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction zip_deflate_fast() {\n  while (zip_lookahead != 0 && zip_qhead == null) {\n    var flush; // set if current block must be flushed\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    zip_INSERT_STRING();\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (\n      zip_hash_head != zip_NIL &&\n      zip_strstart - zip_hash_head <= zip_MAX_DIST\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      zip_match_length = zip_longest_match(zip_hash_head);\n      /* longest_match() sets match_start */\n      if (zip_match_length > zip_lookahead) {\n        zip_match_length = zip_lookahead;\n      }\n    }\n    if (zip_match_length >= zip_MIN_MATCH) {\n      //\t    check_match(strstart, match_start, match_length);\n\n      flush = zip_ct_tally(\n        zip_strstart - zip_match_start,\n        zip_match_length - zip_MIN_MATCH,\n      );\n      zip_lookahead -= zip_match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (zip_match_length <= zip_max_lazy_match) {\n        zip_match_length--; // string at strstart already in hash table\n        do {\n          zip_strstart++;\n          zip_INSERT_STRING();\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n           * these bytes are garbage, but it does not matter since\n           * the next lookahead bytes will be emitted as literals.\n           */\n        } while (--zip_match_length != 0);\n        zip_strstart++;\n      } else {\n        zip_strstart += zip_match_length;\n        zip_match_length = 0;\n        zip_ins_h = zip_window[zip_strstart] & 0xff;\n        //\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n        zip_ins_h =\n          ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) &\n          zip_HASH_MASK;\n\n        //#if MIN_MATCH != 3\n        //\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n      }\n    } else {\n      /* No match, output a literal byte */\n      flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n      zip_lookahead--;\n      zip_strstart++;\n    }\n    if (flush) {\n      zip_flush_block(0);\n      zip_block_start = zip_strstart;\n    }\n\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) {\n      zip_fill_window();\n    }\n  }\n}\n\nfunction zip_deflate_better() {\n  /* Process the input block. */\n  while (zip_lookahead != 0 && zip_qhead == null) {\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    zip_INSERT_STRING();\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    zip_prev_length = zip_match_length;\n    zip_prev_match = zip_match_start;\n    zip_match_length = zip_MIN_MATCH - 1;\n\n    if (\n      zip_hash_head != zip_NIL &&\n      zip_prev_length < zip_max_lazy_match &&\n      zip_strstart - zip_hash_head <= zip_MAX_DIST\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      zip_match_length = zip_longest_match(zip_hash_head);\n      /* longest_match() sets match_start */\n      if (zip_match_length > zip_lookahead) {\n        zip_match_length = zip_lookahead;\n      }\n\n      /* Ignore a length 3 match if it is too distant: */\n      if (\n        zip_match_length == zip_MIN_MATCH &&\n        zip_strstart - zip_match_start > zip_TOO_FAR\n      ) {\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        zip_match_length--;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (\n      zip_prev_length >= zip_MIN_MATCH &&\n      zip_match_length <= zip_prev_length\n    ) {\n      var flush; // set if current block must be flushed\n\n      //\t    check_match(strstart - 1, prev_match, prev_length);\n      flush = zip_ct_tally(\n        zip_strstart - 1 - zip_prev_match,\n        zip_prev_length - zip_MIN_MATCH,\n      );\n\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted.\n       */\n      zip_lookahead -= zip_prev_length - 1;\n      zip_prev_length -= 2;\n      do {\n        zip_strstart++;\n        zip_INSERT_STRING();\n        /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n         * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n         * these bytes are garbage, but it does not matter since the\n         * next lookahead bytes will always be emitted as literals.\n         */\n      } while (--zip_prev_length != 0);\n      zip_match_available = 0;\n      zip_match_length = zip_MIN_MATCH - 1;\n      zip_strstart++;\n      if (flush) {\n        zip_flush_block(0);\n        zip_block_start = zip_strstart;\n      }\n    } else if (zip_match_available != 0) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      if (zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n        zip_flush_block(0);\n        zip_block_start = zip_strstart;\n      }\n      zip_strstart++;\n      zip_lookahead--;\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      zip_match_available = 1;\n      zip_strstart++;\n      zip_lookahead--;\n    }\n\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) {\n      zip_fill_window();\n    }\n  }\n}\n\nfunction zip_init_deflate() {\n  if (zip_eofile) {\n    return;\n  }\n  zip_bi_buf = 0;\n  zip_bi_valid = 0;\n  zip_ct_init();\n  zip_lm_init();\n\n  zip_qhead = null;\n  zip_outcnt = 0;\n  zip_outoff = 0;\n\n  if (zip_compr_level <= 3) {\n    zip_prev_length = zip_MIN_MATCH - 1;\n    zip_match_length = 0;\n  } else {\n    zip_match_length = zip_MIN_MATCH - 1;\n    zip_match_available = 0;\n  }\n\n  zip_complete = false;\n}\n\n/* ==========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction zip_deflate_internal(buff, off, buff_size) {\n  var n;\n\n  if (!zip_initflag) {\n    zip_init_deflate();\n    zip_initflag = true;\n    if (zip_lookahead == 0) {\n      // empty\n      zip_complete = true;\n\n      return 0;\n    }\n  }\n\n  if ((n = zip_qcopy(buff, off, buff_size)) == buff_size) {\n    return buff_size;\n  }\n\n  if (zip_complete) {\n    return n;\n  }\n\n  if (zip_compr_level <= 3) {\n    // optimized for speed\n    zip_deflate_fast();\n  } else {\n    zip_deflate_better();\n  }\n  if (zip_lookahead == 0) {\n    if (zip_match_available != 0) {\n      zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\n    }\n    zip_flush_block(1);\n    zip_complete = true;\n  }\n\n  return n + zip_qcopy(buff, n + off, buff_size - n);\n}\n\nfunction zip_qcopy(buff, off, buff_size) {\n  var n, i, j;\n\n  n = 0;\n  while (zip_qhead != null && n < buff_size) {\n    i = buff_size - n;\n    if (i > zip_qhead.len) {\n      i = zip_qhead.len;\n    }\n    //      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n    for (j = 0; j < i; j++) {\n      buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\n    }\n\n    zip_qhead.off += i;\n    zip_qhead.len -= i;\n    n += i;\n    if (zip_qhead.len == 0) {\n      var p;\n      p = zip_qhead;\n      zip_qhead = zip_qhead.next;\n      zip_reuse_queue(p);\n    }\n  }\n\n  if (n == buff_size) {\n    return n;\n  }\n\n  if (zip_outoff < zip_outcnt) {\n    i = buff_size - n;\n    if (i > zip_outcnt - zip_outoff) {\n      i = zip_outcnt - zip_outoff;\n    }\n    // System.arraycopy(outbuf, outoff, buff, off + n, i);\n    for (j = 0; j < i; j++) {\n      buff[off + n + j] = zip_outbuf[zip_outoff + j];\n    }\n    zip_outoff += i;\n    n += i;\n    if (zip_outcnt == zip_outoff) {\n      zip_outcnt = zip_outoff = 0;\n    }\n  }\n\n  return n;\n}\n\n/* ==========================================================================\n * Allocate the match buffer, initialize the various tables and save the\n * location of the internal file attribute (ascii/binary) and method\n * (DEFLATE/STORE).\n */\nfunction zip_ct_init() {\n  var n; // iterates over tree elements\n  var bits; // bit counter\n  var length; // length value\n  var code; // code value\n  var dist; // distance index\n\n  if (zip_static_dtree[0].dl != 0) return; // ct_init already called\n\n  zip_l_desc.dyn_tree = zip_dyn_ltree;\n  zip_l_desc.static_tree = zip_static_ltree;\n  zip_l_desc.extra_bits = zip_extra_lbits;\n  zip_l_desc.extra_base = zip_LITERALS + 1;\n  zip_l_desc.elems = zip_L_CODES;\n  zip_l_desc.max_length = zip_MAX_BITS;\n  zip_l_desc.max_code = 0;\n\n  zip_d_desc.dyn_tree = zip_dyn_dtree;\n  zip_d_desc.static_tree = zip_static_dtree;\n  zip_d_desc.extra_bits = zip_extra_dbits;\n  zip_d_desc.extra_base = 0;\n  zip_d_desc.elems = zip_D_CODES;\n  zip_d_desc.max_length = zip_MAX_BITS;\n  zip_d_desc.max_code = 0;\n\n  zip_bl_desc.dyn_tree = zip_bl_tree;\n  zip_bl_desc.static_tree = null;\n  zip_bl_desc.extra_bits = zip_extra_blbits;\n  zip_bl_desc.extra_base = 0;\n  zip_bl_desc.elems = zip_BL_CODES;\n  zip_bl_desc.max_length = zip_MAX_BL_BITS;\n  zip_bl_desc.max_code = 0;\n\n  // Initialize the mapping length (0..255) -> length code (0..28)\n  length = 0;\n  for (code = 0; code < zip_LENGTH_CODES - 1; code++) {\n    zip_base_length[code] = length;\n    for (n = 0; n < 1 << zip_extra_lbits[code]; n++) {\n      zip_length_code[length++] = code;\n    }\n  }\n  // Assert (length == 256, \"ct_init: length != 256\");\n\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  zip_length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    zip_base_dist[code] = dist;\n    for (n = 0; n < 1 << zip_extra_dbits[code]; n++) {\n      zip_dist_code[dist++] = code;\n    }\n  }\n  // Assert (dist == 256, \"ct_init: dist != 256\");\n  dist >>= 7; // from now on, all distances are divided by 128\n  for (; code < zip_D_CODES; code++) {\n    zip_base_dist[code] = dist << 7;\n    for (n = 0; n < 1 << (zip_extra_dbits[code] - 7); n++) {\n      zip_dist_code[256 + dist++] = code;\n    }\n  }\n  // Assert (dist == 256, \"ct_init: 256+dist != 512\");\n\n  // Construct the codes of the static literal tree\n  for (bits = 0; bits <= zip_MAX_BITS; bits++) {\n    zip_bl_count[bits] = 0;\n  }\n  n = 0;\n  while (n <= 143) {\n    zip_static_ltree[n++].dl = 8;\n    zip_bl_count[8]++;\n  }\n  while (n <= 255) {\n    zip_static_ltree[n++].dl = 9;\n    zip_bl_count[9]++;\n  }\n  while (n <= 279) {\n    zip_static_ltree[n++].dl = 7;\n    zip_bl_count[7]++;\n  }\n  while (n <= 287) {\n    zip_static_ltree[n++].dl = 8;\n    zip_bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < zip_D_CODES; n++) {\n    zip_static_dtree[n].dl = 5;\n    zip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n  }\n\n  // Initialize the first block of the first file:\n  zip_init_block();\n}\n\n/* ==========================================================================\n * Initialize a new block.\n */\nfunction zip_init_block() {\n  var n; // iterates over tree elements\n\n  // Initialize the trees.\n  for (n = 0; n < zip_L_CODES; n++) zip_dyn_ltree[n].fc = 0;\n  for (n = 0; n < zip_D_CODES; n++) zip_dyn_dtree[n].fc = 0;\n  for (n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n\n  zip_dyn_ltree[zip_END_BLOCK].fc = 1;\n  zip_opt_len = zip_static_len = 0;\n  zip_last_lit = zip_last_dist = zip_last_flags = 0;\n  zip_flags = 0;\n  zip_flag_bit = 1;\n}\n\n/* ==========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction zip_pqdownheap(\n  tree, // the tree to restore\n  k,\n) {\n  // node to move down\n  var v = zip_heap[k];\n  var j = k << 1; // left son of k\n\n  while (j <= zip_heap_len) {\n    // Set j to the smallest of the two sons:\n    if (j < zip_heap_len && zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j])) {\n      j++;\n    }\n\n    // Exit if v is smaller than both sons\n    if (zip_SMALLER(tree, v, zip_heap[j])) {\n      break;\n    }\n\n    // Exchange v with the smallest son\n    zip_heap[k] = zip_heap[j];\n    k = j;\n\n    // And continue down the tree, setting j to the left son of k\n    j <<= 1;\n  }\n  zip_heap[k] = v;\n}\n\n/* ==========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction zip_gen_bitlen(desc) {\n  // the tree descriptor\n  var tree = desc.dyn_tree;\n  var extra = desc.extra_bits;\n  var base = desc.extra_base;\n  var max_code = desc.max_code;\n  var max_length = desc.max_length;\n  var stree = desc.static_tree;\n  var h; // heap index\n  var n, m; // iterate over the tree elements\n  var bits; // bit length\n  var xbits; // extra bits\n  var f; // frequency\n  var overflow = 0; // number of elements with bit length too large\n\n  for (bits = 0; bits <= zip_MAX_BITS; bits++) {\n    zip_bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n\n  for (h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n    n = zip_heap[h];\n    bits = tree[tree[n].dl].dl + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n].dl = bits;\n    // We overwrite tree[n].dl which is no longer needed\n\n    if (n > max_code) {\n      continue;\n    } // not a leaf node\n\n    zip_bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n].fc;\n    zip_opt_len += f * (bits + xbits);\n    if (stree != null) {\n      zip_static_len += f * (stree[n].dl + xbits);\n    }\n  }\n  if (overflow == 0) {\n    return;\n  }\n\n  // This happens for example on obj2 and pic of the Calgary corpus\n\n  // Find the first bit length which could increase:\n  do {\n    bits = max_length - 1;\n    while (zip_bl_count[bits] == 0) {\n      bits--;\n    }\n    zip_bl_count[bits]--; // move one leaf down the tree\n    zip_bl_count[bits + 1] += 2; // move one overflow item as its brother\n    zip_bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits != 0; bits--) {\n    n = zip_bl_count[bits];\n    while (n != 0) {\n      m = zip_heap[--h];\n      if (m > max_code) {\n        continue;\n      }\n      if (tree[m].dl != bits) {\n        zip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n        tree[m].fc = bits;\n      }\n      n--;\n    }\n  }\n}\n\n/* ==========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction zip_gen_codes(\n  tree, // the tree to decorate\n  max_code,\n) {\n  // largest code with non zero frequency\n  var next_code = new Array(zip_MAX_BITS + 1); // next code value for each bit length\n  var code = 0; // running code value\n  var bits; // bit index\n  var n; // code index\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= zip_MAX_BITS; bits++) {\n    code = (code + zip_bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //\t    \"inconsistent bit counts\");\n  //    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n].dl;\n    if (len == 0) {\n      continue;\n    }\n    // Now reverse the bits\n    tree[n].fc = zip_bi_reverse(next_code[len]++, len);\n\n    //      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n  }\n}\n\n/* ==========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction zip_build_tree(desc) {\n  // the tree descriptor\n  var tree = desc.dyn_tree;\n  var stree = desc.static_tree;\n  var elems = desc.elems;\n  var n, m; // iterate over heap elements\n  var max_code = -1; // largest code with non zero frequency\n  var node = elems; // next internal node of the tree\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  zip_heap_len = 0;\n  zip_heap_max = zip_HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n].fc != 0) {\n      zip_heap[++zip_heap_len] = max_code = n;\n      zip_depth[n] = 0;\n    } else {\n      tree[n].dl = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (zip_heap_len < 2) {\n    var xnew = (zip_heap[++zip_heap_len] = max_code < 2 ? ++max_code : 0);\n    tree[xnew].fc = 1;\n    zip_depth[xnew] = 0;\n    zip_opt_len--;\n    if (stree != null) {\n      zip_static_len -= stree[xnew].dl;\n    }\n    // new is 0 or 1 so it does not have extra bits\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = zip_heap_len >> 1; n >= 1; n--) {\n    zip_pqdownheap(tree, n);\n  }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  do {\n    n = zip_heap[zip_SMALLEST];\n    zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n    zip_pqdownheap(tree, zip_SMALLEST);\n\n    m = zip_heap[zip_SMALLEST]; // m = node of next least frequency\n\n    // keep the nodes sorted by frequency\n    zip_heap[--zip_heap_max] = n;\n    zip_heap[--zip_heap_max] = m;\n\n    // Create a new node father of n and m\n    tree[node].fc = tree[n].fc + tree[m].fc;\n    //\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n    if (zip_depth[n] > zip_depth[m] + 1) {\n      zip_depth[node] = zip_depth[n];\n    } else {\n      zip_depth[node] = zip_depth[m] + 1;\n    }\n    tree[n].dl = tree[m].dl = node;\n\n    // and insert the new node in the heap\n    zip_heap[zip_SMALLEST] = node++;\n    zip_pqdownheap(tree, zip_SMALLEST);\n  } while (zip_heap_len >= 2);\n\n  zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  zip_gen_bitlen(desc);\n\n  // The field len is now set, we can generate the bit codes\n  zip_gen_codes(tree, max_code);\n}\n\n/* ==========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree. Updates opt_len to take into account the repeat\n * counts. (The contribution of the bit length codes will be added later\n * during the construction of bl_tree.)\n */\nfunction zip_scan_tree(\n  tree, // the tree to be scanned\n  max_code,\n) {\n  // and its largest code of non zero frequency\n  var n; // iterates over all tree elements\n  var prevlen = -1; // last emitted length\n  var curlen; // length of current code\n  var nextlen = tree[0].dl; // length of next code\n  var count = 0; // repeat count of the current code\n  var max_count = 7; // max repeat count\n  var min_count = 4; // min repeat count\n\n  if (nextlen == 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[max_code + 1].dl = 0xffff; // guard\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl;\n    if (++count < max_count && curlen == nextlen) {\n      continue;\n    } else if (count < min_count) {\n      zip_bl_tree[curlen].fc += count;\n    } else if (curlen != 0) {\n      if (curlen != prevlen) {\n        zip_bl_tree[curlen].fc++;\n      }\n      zip_bl_tree[zip_REP_3_6].fc++;\n    } else if (count <= 10) {\n      zip_bl_tree[zip_REPZ_3_10].fc++;\n    } else {\n      zip_bl_tree[zip_REPZ_11_138].fc++;\n    }\n    count = 0;\n    prevlen = curlen;\n    if (nextlen == 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen == nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n/* ==========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction zip_send_tree(\n  tree, // the tree to be scanned\n  max_code,\n) {\n  // and its largest code of non zero frequency\n  var n; // iterates over all tree elements\n  var prevlen = -1; // last emitted length\n  var curlen; // length of current code\n  var nextlen = tree[0].dl; // length of next code\n  var count = 0; // repeat count of the current code\n  var max_count = 7; // max repeat count\n  var min_count = 4; // min repeat count\n\n  /* tree[max_code+1].dl = -1; */ /* guard already set */\n  if (nextlen == 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl;\n    if (++count < max_count && curlen == nextlen) {\n      continue;\n    } else if (count < min_count) {\n      do {\n        zip_SEND_CODE(curlen, zip_bl_tree);\n      } while (--count != 0);\n    } else if (curlen != 0) {\n      if (curlen != prevlen) {\n        zip_SEND_CODE(curlen, zip_bl_tree);\n        count--;\n      }\n      // Assert(count >= 3 && count <= 6, \" 3_6?\");\n      zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n      zip_send_bits(count - 3, 2);\n    } else if (count <= 10) {\n      zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n      zip_send_bits(count - 3, 3);\n    } else {\n      zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n      zip_send_bits(count - 11, 7);\n    }\n    count = 0;\n    prevlen = curlen;\n    if (nextlen == 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen == nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n/* ==========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction zip_build_bl_tree() {\n  var max_blindex; // index of last bit length code of non zero freq\n\n  // Determine the bit length frequencies for literal and distance trees\n  zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n  zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n\n  // Build the bit length tree:\n  zip_build_tree(zip_bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = zip_BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  zip_opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n\n  return max_blindex;\n}\n\n/* ==========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction zip_send_all_trees(lcodes, dcodes, blcodes) {\n  // number of codes for each tree\n  var rank; // index in bl_order\n\n  //    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //\t    \"too many codes\");\n  //    Tracev((stderr, \"\\nbl counts: \"));\n  zip_send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n  zip_send_bits(dcodes - 1, 5);\n  zip_send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n  for (rank = 0; rank < blcodes; rank++) {\n    //      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n  }\n\n  // send the literal tree\n  zip_send_tree(zip_dyn_ltree, lcodes - 1);\n\n  // send the distance tree\n  zip_send_tree(zip_dyn_dtree, dcodes - 1);\n}\n\n/* ==========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction zip_flush_block(eof) {\n  // true if this is the last block for a file\n  var opt_lenb, static_lenb; // opt_len and static_len in bytes\n  var max_blindex; // index of last bit length code of non zero freq\n  var stored_len; // length of input block\n\n  stored_len = zip_strstart - zip_block_start;\n  zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n\n  // Construct the literal and distance trees\n  zip_build_tree(zip_l_desc);\n  //    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n\n  zip_build_tree(zip_d_desc);\n  //    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n  /* At this point, opt_len and static_len are the total bit lengths of\n   * the compressed block data, excluding the tree representations.\n   */\n\n  /* Build the bit length tree for the above two trees, and get the index\n   * in bl_order of the last bit length code to send.\n   */\n  max_blindex = zip_build_bl_tree();\n\n  // Determine the best encoding. Compute first the block length in bytes\n  opt_lenb = (zip_opt_len + 3 + 7) >> 3;\n  static_lenb = (zip_static_len + 3 + 7) >> 3;\n\n  //    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n  //\t   opt_lenb, encoder->opt_len,\n  //\t   static_lenb, encoder->static_len, stored_len,\n  //\t   encoder->last_lit, encoder->last_dist));\n\n  if (static_lenb <= opt_lenb) {\n    opt_lenb = static_lenb;\n  }\n  if (\n    stored_len + 4 <= opt_lenb && // 4: two words for the lengths\n    zip_block_start >= 0\n  ) {\n    var i;\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    zip_send_bits((zip_STORED_BLOCK << 1) + eof, 3); /* send block type */\n    zip_bi_windup(); /* align on byte boundary */\n    zip_put_short(stored_len);\n    zip_put_short(~stored_len);\n\n    // copy block\n    /*\n      p = &window[block_start];\n      for(i = 0; i < stored_len; i++)\n  put_byte(p[i]);\n  */\n    for (i = 0; i < stored_len; i++) {\n      zip_put_byte(zip_window[zip_block_start + i]);\n    }\n  } else if (static_lenb == opt_lenb) {\n    zip_send_bits((zip_STATIC_TREES << 1) + eof, 3);\n    zip_compress_block(zip_static_ltree, zip_static_dtree);\n  } else {\n    zip_send_bits((zip_DYN_TREES << 1) + eof, 3);\n    zip_send_all_trees(\n      zip_l_desc.max_code + 1,\n      zip_d_desc.max_code + 1,\n      max_blindex + 1,\n    );\n    zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n  }\n\n  zip_init_block();\n\n  if (eof != 0) {\n    zip_bi_windup();\n  }\n}\n\n/* ==========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction zip_ct_tally(\n  dist, // distance of matched string\n  lc,\n) {\n  // match length-MIN_MATCH or unmatched char (if dist==0)\n  zip_l_buf[zip_last_lit++] = lc;\n  if (dist == 0) {\n    // lc is the unmatched char\n    zip_dyn_ltree[lc].fc++;\n  } else {\n    // Here, lc is the match length - MIN_MATCH\n    dist--; // dist = match distance - 1\n    //      Assert((ush)dist < (ush)MAX_DIST &&\n    //\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n    zip_dyn_ltree[zip_length_code[lc] + zip_LITERALS + 1].fc++;\n    zip_dyn_dtree[zip_D_CODE(dist)].fc++;\n\n    zip_d_buf[zip_last_dist++] = dist;\n    zip_flags |= zip_flag_bit;\n  }\n  zip_flag_bit <<= 1;\n\n  // Output the flags if they fill a byte\n  if ((zip_last_lit & 7) == 0) {\n    zip_flag_buf[zip_last_flags++] = zip_flags;\n    zip_flags = 0;\n    zip_flag_bit = 1;\n  }\n  // Try to guess if it is profitable to stop the current block here\n  if (zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\n    // Compute an upper bound for the compressed length\n    var out_length = zip_last_lit * 8;\n    var in_length = zip_strstart - zip_block_start;\n    var dcode;\n\n    for (dcode = 0; dcode < zip_D_CODES; dcode++) {\n      out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n    }\n    out_length >>= 3;\n    //      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n    //\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n    //\t     100L - out_length*100L/in_length));\n    if (\n      zip_last_dist < parseInt(zip_last_lit / 2) &&\n      out_length < parseInt(in_length / 2)\n    ) {\n      return true;\n    }\n  }\n\n  return (\n    zip_last_lit == zip_LIT_BUFSIZE - 1 || zip_last_dist == zip_DIST_BUFSIZE\n  );\n  /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\n/* ==========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction zip_compress_block(\n  ltree, // literal tree\n  dtree,\n) {\n  // distance tree\n  var dist; // distance of matched string\n  var lc; // match length or unmatched char (if dist == 0)\n  var lx = 0; // running index in l_buf\n  var dx = 0; // running index in d_buf\n  var fx = 0; // running index in flag_buf\n  var flag = 0; // current flags\n  var code; // the code to send\n  var extra; // number of extra bits to send\n\n  if (zip_last_lit != 0) {\n    do {\n      if ((lx & 7) == 0) {\n        flag = zip_flag_buf[fx++];\n      }\n      lc = zip_l_buf[lx++] & 0xff;\n      if ((flag & 1) == 0) {\n        zip_SEND_CODE(lc, ltree); /* send a literal byte */\n        //\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        // Here, lc is the match length - MIN_MATCH\n        code = zip_length_code[lc];\n        zip_SEND_CODE(code + zip_LITERALS + 1, ltree); // send the length code\n        extra = zip_extra_lbits[code];\n        if (extra != 0) {\n          lc -= zip_base_length[code];\n          zip_send_bits(lc, extra); // send the extra length bits\n        }\n        dist = zip_d_buf[dx++];\n        // Here, dist is the match distance - 1\n        code = zip_D_CODE(dist);\n        //\tAssert (code < D_CODES, \"bad d_code\");\n\n        zip_SEND_CODE(code, dtree); // send the distance code\n        extra = zip_extra_dbits[code];\n        if (extra != 0) {\n          dist -= zip_base_dist[code];\n          zip_send_bits(dist, extra); // send the extra distance bits\n        }\n      } // literal or match pair ?\n      flag >>= 1;\n    } while (lx < zip_last_lit);\n  }\n\n  zip_SEND_CODE(zip_END_BLOCK, ltree);\n}\n\n/* ==========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nvar zip_Buf_size = 16; // bit size of bi_buf\nfunction zip_send_bits(\n  value, // value to send\n  length,\n) {\n  // number of bits\n  /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n   * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n   * unused bits in value.\n   */\n  if (zip_bi_valid > zip_Buf_size - length) {\n    zip_bi_buf |= value << zip_bi_valid;\n    zip_put_short(zip_bi_buf);\n    zip_bi_buf = value >> (zip_Buf_size - zip_bi_valid);\n    zip_bi_valid += length - zip_Buf_size;\n  } else {\n    zip_bi_buf |= value << zip_bi_valid;\n    zip_bi_valid += length;\n  }\n}\n\n/* ==========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction zip_bi_reverse(\n  code, // the value to invert\n  len,\n) {\n  // its bit length\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>= 1;\n    res <<= 1;\n  } while (--len > 0);\n\n  return res >> 1;\n}\n\n/* ==========================================================================\n * Write out any remaining bits in an incomplete byte.\n */\nfunction zip_bi_windup() {\n  if (zip_bi_valid > 8) {\n    zip_put_short(zip_bi_buf);\n  } else if (zip_bi_valid > 0) {\n    zip_put_byte(zip_bi_buf);\n  }\n  zip_bi_buf = 0;\n  zip_bi_valid = 0;\n}\n\nfunction zip_qoutbuf() {\n  if (zip_outcnt != 0) {\n    var q, i;\n    q = zip_new_queue();\n    if (zip_qhead == null) {\n      zip_qhead = zip_qtail = q;\n    } else {\n      zip_qtail = zip_qtail.next = q;\n    }\n    q.len = zip_outcnt - zip_outoff;\n    //      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n    for (i = 0; i < q.len; i++) {\n      q.ptr[i] = zip_outbuf[zip_outoff + i];\n    }\n    zip_outcnt = zip_outoff = 0;\n  }\n}\n\nexport function zip_deflate(str, level) {\n  var out, buff;\n  var i, j;\n\n  zip_deflate_data = str;\n  zip_deflate_pos = 0;\n  if (typeof level === \"undefined\") {\n    level = zip_DEFAULT_LEVEL;\n  }\n  zip_deflate_start(level);\n\n  buff = new Array(1024);\n  out = \"\";\n  while ((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n    for (j = 0; j < i; j++) {\n      out += String.fromCharCode(buff[j]);\n    }\n  }\n  zip_deflate_data = null; // G.C.\n\n  return out;\n}\n\nexport function encode64(data) {\n  var r = \"\";\n  for (var i = 0; i < data.length; i += 3) {\n    if (i + 2 == data.length) {\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\n    } else if (i + 1 == data.length) {\n      r += append3bytes(data.charCodeAt(i), 0, 0);\n    } else {\n      r += append3bytes(\n        data.charCodeAt(i),\n        data.charCodeAt(i + 1),\n        data.charCodeAt(i + 2),\n      );\n    }\n  }\n\n  return r;\n}\n\nfunction append3bytes(b1, b2, b3) {\n  var c1 = b1 >> 2;\n  var c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\n  var c3 = ((b2 & 0xf) << 2) | (b3 >> 6);\n  var c4 = b3 & 0x3f;\n  var r = \"\";\n  r += encode6bit(c1 & 0x3f);\n  r += encode6bit(c2 & 0x3f);\n  r += encode6bit(c3 & 0x3f);\n  r += encode6bit(c4 & 0x3f);\n\n  return r;\n}\n\nfunction encode6bit(b) {\n  if (b < 10) {\n    return String.fromCharCode(48 + b);\n  }\n  b -= 10;\n  if (b < 26) {\n    return String.fromCharCode(65 + b);\n  }\n  b -= 26;\n  if (b < 26) {\n    return String.fromCharCode(97 + b);\n  }\n  b -= 26;\n  if (b == 0) {\n    return \"-\";\n  }\n  if (b == 1) {\n    return \"_\";\n  }\n\n  return \"?\";\n}\n","import { uml } from \"@mdit/plugin-uml\";\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport { encode64, zip_deflate } from \"./lib/deflate.js\";\nimport type { MarkdownItPlantumlOptions } from \"./options.js\";\n\nexport const plantuml: PluginWithOptions<MarkdownItPlantumlOptions> = (\n  md,\n  {\n    type = \"uml\",\n    name = \"uml\",\n    open = `start${name}`,\n    close = `end${name}`,\n    fence = name,\n    format = \"svg\",\n    server = \"https://www.plantuml.com/plantuml\",\n    srcGetter = (content: string): string =>\n      `${server}/${format}/${encode64(\n        zip_deflate(\n          unescape(\n            encodeURIComponent(`@start${name}\\n${content.trim()}\\n@end${name}`),\n          ),\n          9,\n        ),\n      )}`,\n    render = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n      const { content, info = \"plantuml diagram\" } = token;\n\n      token.tag = \"img\";\n      token.attrPush([\"src\", srcGetter(content)]);\n      token.attrPush([\"alt\", info]);\n\n      return self.renderToken(tokens, index, options);\n    },\n  } = {},\n) => {\n  if (type === \"uml\") {\n    md.use(uml, {\n      name,\n      open,\n      close,\n      render,\n    });\n  } else {\n    // Handle ```name  blocks\n    const fenceRender = md.renderer.rules.fence!;\n\n    md.renderer.rules.fence = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      const [fenceName, alt] = token.info.split(\" \", 2);\n\n      if (fenceName === fence) {\n        token.info = alt;\n\n        return render(tokens, index, options, env, self);\n      }\n\n      return fenceRender(tokens, index, options, env, self);\n    };\n  }\n};\n"],"names":["zip_WSIZE","zip_STORED_BLOCK","zip_STATIC_TREES","zip_DYN_TREES","zip_FULL_SEARCH","zip_INBUFSIZ","zip_INBUF_EXTRA","zip_OUTBUFSIZ","zip_window_size","zip_MIN_MATCH","zip_MAX_MATCH","zip_BITS","zip_LIT_BUFSIZE","zip_HASH_BITS","zip_DIST_BUFSIZE","zip_HASH_SIZE","zip_HASH_MASK","zip_WMASK","zip_NIL","zip_TOO_FAR","zip_MIN_LOOKAHEAD","zip_MAX_DIST","zip_SMALLEST","zip_MAX_BITS","zip_MAX_BL_BITS","zip_LENGTH_CODES","zip_LITERALS","zip_END_BLOCK","zip_L_CODES","zip_D_CODES","zip_BL_CODES","zip_REP_3_6","zip_REPZ_3_10","zip_REPZ_11_138","zip_HEAP_SIZE","zip_H_SHIFT","zip_free_queue","zip_qhead","zip_qtail","zip_initflag","zip_outbuf","zip_outcnt","zip_outoff","zip_complete","zip_window","zip_d_buf","zip_l_buf","zip_prev","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_eofile","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_compr_level","zip_good_match","zip_dyn_ltree","zip_dyn_dtree","zip_static_ltree","zip_static_dtree","zip_bl_tree","zip_l_desc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_heap","zip_heap_len","zip_heap_max","zip_depth","zip_length_code","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_deflate_data","zip_deflate_pos","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_DeflateConfiguration","zip_DeflateCT","zip_DeflateTreeDesc","a","b","c","d","zip_DeflateBuffer","zip_deflate_start","level","i","zip_reuse_queue","p","zip_new_queue","zip_head1","zip_head2","val","zip_put_byte","zip_qoutbuf","zip_put_short","w","zip_INSERT_STRING","zip_SEND_CODE","tree","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","n","m","zip_read_buff","buff","offset","zip_lm_init","j","zip_fill_window","zip_longest_match","cur_match","chain_length","scanp","matchp","len","best_len","limit","strendp","scan_end1","scan_end","more","zip_deflate_fast","flush","zip_ct_tally","zip_flush_block","zip_deflate_better","zip_init_deflate","zip_ct_init","zip_deflate_internal","off","buff_size","zip_qcopy","bits","length","code","zip_gen_codes","zip_bi_reverse","zip_init_block","zip_pqdownheap","k","v","zip_gen_bitlen","desc","extra","base","max_code","max_length","stree","h","xbits","f","overflow","next_code","zip_build_tree","elems","node","xnew","zip_scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","zip_send_tree","zip_build_bl_tree","max_blindex","zip_send_all_trees","lcodes","dcodes","blcodes","rank","eof","opt_lenb","static_lenb","stored_len","zip_bi_windup","zip_compress_block","lc","out_length","in_length","dcode","ltree","dtree","lx","dx","fx","flag","zip_Buf_size","value","res","q","zip_deflate","str","out","encode64","data","r","append3bytes","b1","b2","b3","c1","c2","c3","c4","encode6bit","plantuml","md","type","name","open","close","fence","format","server","srcGetter","content","render","tokens","index","options","_env","self","token","info","uml","fenceRender","env","fenceName","alt"],"mappings":"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"}