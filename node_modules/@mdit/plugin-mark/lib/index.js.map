{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-mark/blob/master/index.mjs\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\nimport type { Delimiter } from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\n/*\n * Insert each marker as a separate text token, and add it to delimiter list\n *\n */\nconst tokenize: RuleInline = (state, silent) => {\n  const start = state.pos;\n  const marker = state.src.charAt(start);\n\n  if (silent || marker !== \"=\") return false;\n\n  const scanned = state.scanDelims(state.pos, true);\n  let { length } = scanned;\n\n  if (length < 2) return false;\n\n  if (length % 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = marker;\n    length--;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = `${marker}${marker}`;\n\n    if (scanned.can_open || scanned.can_close)\n      state.delimiters.push({\n        marker: 0x3d,\n        length: 0, // disable \"rule of 3\" length checks meant for emphasis\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close,\n      });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n/*\n * Walk through delimiter list and replace text tokens with tags\n *\n */\nconst postProcess = (state: StateInline, delimiters: Delimiter[]): void => {\n  let token;\n  const loneMarkers = [];\n  const max = delimiters.length;\n\n  for (let i = 0; i < max; i++) {\n    const startDelim = delimiters[i];\n\n    if (startDelim.marker === 0x3d /* = */ && startDelim.end !== -1) {\n      const endDelim = delimiters[startDelim.end];\n\n      token = state.tokens[startDelim.token];\n      token.type = \"mark_open\";\n      token.tag = \"mark\";\n      token.nesting = 1;\n      token.markup = \"==\";\n      token.content = \"\";\n\n      token = state.tokens[endDelim.token];\n      token.type = \"mark_close\";\n      token.tag = \"mark\";\n      token.nesting = -1;\n      token.markup = \"==\";\n      token.content = \"\";\n\n      if (\n        state.tokens[endDelim.token - 1].type === \"text\" &&\n        state.tokens[endDelim.token - 1].content === \"=\"\n      )\n        loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  /*\n   * If a marker sequence has an odd number of characters, itâ€™s splitted\n   * like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n   * start of the sequence.\n   *\n   * So, we have to move all those markers after subsequent s_close tags.\n   *\n   */\n  while (loneMarkers.length) {\n    const i = loneMarkers.pop()!;\n    let j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === \"mark_close\")\n      j++;\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\nexport const mark: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"mark\", tokenize);\n  md.inline.ruler2.before(\"emphasis\", \"mark\", (state) => {\n    const tokensMeta = state.tokens_meta || [];\n\n    postProcess(state, state.delimiters);\n\n    for (const tokenMeta of tokensMeta) {\n      if (tokenMeta?.delimiters) postProcess(state, tokenMeta.delimiters);\n    }\n\n    return true;\n  });\n};\n"],"names":["tokenize","state","silent","start","marker","scanned","length","token","i","postProcess","delimiters","loneMarkers","max","startDelim","endDelim","j","mark","md","tokensMeta","tokenMeta"],"mappings":"AAaA,MAAMA,EAAuB,CAACC,EAAOC,IAAW,CAC9C,MAAMC,EAAQF,EAAM,IACdG,EAASH,EAAM,IAAI,OAAOE,CAAK,EAErC,GAAID,GAAUE,IAAW,IAAK,MAAO,GAErC,MAAMC,EAAUJ,EAAM,WAAWA,EAAM,IAAK,EAAI,EAChD,GAAI,CAAE,OAAAK,CAAO,EAAID,EAEjB,GAAIC,EAAS,EAAG,MAAO,GAEvB,GAAIA,EAAS,EAAG,CACd,MAAMC,EAAQN,EAAM,KAAK,OAAQ,GAAI,CAAC,EAEtCM,EAAM,QAAUH,EAChBE,GACF,CAEA,QAASE,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAAG,CAClC,MAAMD,EAAQN,EAAM,KAAK,OAAQ,GAAI,CAAC,EAEtCM,EAAM,QAAU,GAAGH,CAAM,GAAGA,CAAM,IAE9BC,EAAQ,UAAYA,EAAQ,YAC9BJ,EAAM,WAAW,KAAK,CACpB,OAAQ,GACR,OAAQ,EACR,MAAOA,EAAM,OAAO,OAAS,EAC7B,IAAK,GACL,KAAMI,EAAQ,SACd,MAAOA,EAAQ,SACjB,CAAC,CACL,CAEA,OAAAJ,EAAM,KAAOI,EAAQ,OAEd,EACT,EAMMI,EAAc,CAACR,EAAoBS,IAAkC,CACzE,IAAIH,EACJ,MAAMI,EAAc,CAAC,EACfC,EAAMF,EAAW,OAEvB,QAASF,EAAI,EAAGA,EAAII,EAAKJ,IAAK,CAC5B,MAAMK,EAAaH,EAAWF,CAAC,EAE/B,GAAIK,EAAW,SAAW,IAAgBA,EAAW,MAAQ,GAAI,CAC/D,MAAMC,EAAWJ,EAAWG,EAAW,GAAG,EAE1CN,EAAQN,EAAM,OAAOY,EAAW,KAAK,EACrCN,EAAM,KAAO,YACbA,EAAM,IAAM,OACZA,EAAM,QAAU,EAChBA,EAAM,OAAS,KACfA,EAAM,QAAU,GAEhBA,EAAQN,EAAM,OAAOa,EAAS,KAAK,EACnCP,EAAM,KAAO,aACbA,EAAM,IAAM,OACZA,EAAM,QAAU,GAChBA,EAAM,OAAS,KACfA,EAAM,QAAU,GAGdN,EAAM,OAAOa,EAAS,MAAQ,CAAC,EAAE,OAAS,QAC1Cb,EAAM,OAAOa,EAAS,MAAQ,CAAC,EAAE,UAAY,KAE7CH,EAAY,KAAKG,EAAS,MAAQ,CAAC,CACvC,CACF,CAUA,KAAOH,EAAY,QAAQ,CACzB,MAAMH,EAAIG,EAAY,IAAI,EAC1B,IAAII,EAAIP,EAAI,EAEZ,KAAOO,EAAId,EAAM,OAAO,QAAUA,EAAM,OAAOc,CAAC,EAAE,OAAS,cACzDA,IAEFA,IAEIP,IAAMO,IACRR,EAAQN,EAAM,OAAOc,CAAC,EACtBd,EAAM,OAAOc,CAAC,EAAId,EAAM,OAAOO,CAAC,EAChCP,EAAM,OAAOO,CAAC,EAAID,EAEtB,CACF,EAEaS,EAAsBC,GAAO,CACxCA,EAAG,OAAO,MAAM,OAAO,WAAY,OAAQjB,CAAQ,EACnDiB,EAAG,OAAO,OAAO,OAAO,WAAY,OAAShB,GAAU,CACrD,MAAMiB,EAAajB,EAAM,aAAe,CAAC,EAEzCQ,EAAYR,EAAOA,EAAM,UAAU,EAEnC,UAAWkB,KAAaD,EAClBC,GAAW,YAAYV,EAAYR,EAAOkB,EAAU,UAAU,EAGpE,MAAO,EACT,CAAC,CACH"}