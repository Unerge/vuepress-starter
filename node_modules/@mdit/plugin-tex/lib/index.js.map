{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Test if potential opening or closing delimiter\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevChar = pos > 0 ? state.src.charAt(pos - 1) : \"\";\n  const nextChar = pos + 1 <= state.posMax ? state.src.charAt(pos + 1) : \"\";\n\n  return {\n    canOpen: allowInlineWithSpace || (nextChar !== \" \" && nextChar !== \"\\t\"),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isnâ€™t followed by a number\n     */\n    canClose:\n      !/[0-9]/u.exec(nextChar) &&\n      (allowInlineWithSpace || (prevChar !== \" \" && prevChar !== \"\\t\")),\n  };\n};\n\nconst getInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    let match;\n    let pos;\n    let res;\n    let token;\n\n    if (state.src[state.pos] !== \"$\") return false;\n\n    res = isValidDelim(state, state.pos, allowInlineWithSpace);\n    if (!res.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    match = start;\n    while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src[pos] === \"\\\\\") pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match, allowInlineWithSpace);\n\n    if (!res.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      token = state.push(\"math_inline\", \"math\", 0);\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\nconst blockTex: RuleBlock = (state, start, end, silent) => {\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"$$\") return false;\n\n  pos += 2;\n  let firstLine = state.src.slice(pos, max);\n\n  if (silent) return true;\n\n  let found = false;\n\n  if (firstLine.trim().endsWith(\"$$\")) {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  let next = start;\n  let lastLine: string | null = null;\n\n  while (!found) {\n    next++;\n\n    if (next >= end) break;\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent)\n      // non-empty line with negative indent should stop the list:\n      break;\n\n    if (state.src.slice(pos, max).trim().endsWith(\"$$\")) {\n      lastLine = state.src.slice(\n        pos,\n        state.src.slice(0, max).lastIndexOf(\"$$\"),\n      );\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine?.trim() ? `\\n${firstLine}\\n` : \"\\n\") +\n    state.getLines(start + 1, next, state.tShift[start], true) +\n    (lastLine?.trim() ?? \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    render,\n  } = options ?? {};\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      return fence!(...args);\n    };\n  }\n\n  md.inline.ruler.after(\n    \"escape\",\n    \"math_inline\",\n    getInlineTex(allowInlineWithSpace),\n  );\n  md.block.ruler.after(\"blockquote\", \"math_block\", blockTex, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[\"math_inline\"] = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules[\"math_block\"] = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["isValidDelim","state","pos","allowInlineWithSpace","prevChar","nextChar","getInlineTex","silent","match","res","token","start","blockTex","end","max","firstLine","found","next","lastLine","tex","md","options","mathFence","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"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"}