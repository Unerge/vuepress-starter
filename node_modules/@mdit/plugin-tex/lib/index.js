const f=(t,r,l)=>{const c=r>0?t.src.charAt(r-1):"",e=r+1<=t.posMax?t.src.charAt(r+1):"";return{canOpen:l||e!==" "&&e!=="	",canClose:!/[0-9]/u.exec(e)&&(l||c!==" "&&c!=="	")}},u=t=>(r,l)=>{let c,e,s,i;if(r.src[r.pos]!=="$")return!1;if(s=f(r,r.pos,t),!s.canOpen)return l||(r.pending+="$"),r.pos++,!0;const n=r.pos+1;for(c=n;(c=r.src.indexOf("$",c))!==-1;){for(e=c-1;r.src[e]==="\\";)e--;if((c-e)%2===1)break;c++}return c===-1?(l||(r.pending+="$"),r.pos=n,!0):c-n===0?(l||(r.pending+="$$"),r.pos=n+1,!0):(s=f(r,c,t),s.canClose?(l||(i=r.push("math_inline","math",0),i.markup="$",i.content=r.src.slice(n,c)),r.pos=c+1,!0):(l||(r.pending+="$"),r.pos=n,!0))},m=(t,r,l,c)=>{let e=t.bMarks[r]+t.tShift[r],s=t.eMarks[r];if(e+2>s||t.src.slice(e,e+2)!=="$$")return!1;e+=2;let i=t.src.slice(e,s);if(c)return!0;let n=!1;i.trim().endsWith("$$")&&(i=i.trim().slice(0,-2),n=!0);let o=r,p=null;for(;!n&&(o++,!(o>=l||(e=t.bMarks[o]+t.tShift[o],s=t.eMarks[o],e<s&&t.tShift[o]<t.blkIndent)));)t.src.slice(e,s).trim().endsWith("$$")&&(p=t.src.slice(e,t.src.slice(0,s).lastIndexOf("$$")),n=!0);t.line=o+1;const a=t.push("math_block","math",0);return a.block=!0,a.content=(i?.trim()?`
${i}
`:`
`)+t.getLines(r+1,o,t.tShift[r],!0)+(p?.trim()??""),a.map=[r,t.line],a.markup="$$",!0},$=(t,r)=>{if(typeof r?.render!="function")throw new Error('[@mdit/plugin-tex]: "render" option should be a function');const{allowInlineWithSpace:l=!1,mathFence:c=!1,render:e}=r??{};if(c){const s=t.renderer.rules.fence;t.renderer.rules.fence=(...i)=>{const[n,o,,p]=i,{content:a,info:h}=n[o];return h.trim()==="math"?e(a,!0,p):s(...i)}}t.inline.ruler.after("escape","math_inline",u(l)),t.block.ruler.after("blockquote","math_block",m,{alt:["paragraph","reference","blockquote","list"]}),t.renderer.rules.math_inline=(s,i,n,o)=>e(s[i].content,!1,o),t.renderer.rules.math_block=(s,i,n,o)=>e(s[i].content,!0,o)};export{$ as tex};
//# sourceMappingURL=index.js.map
