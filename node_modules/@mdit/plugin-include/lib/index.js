import k from"node:fs";import h from"upath";const b=/\r\n?|\n/g,E=e=>{const r=e.split(`
`),i=r.reduce((l,s)=>{for(let n=0;n<s.length;n++)if(s[n]!==" "&&s[n]!=="	")return Math.min(n,l);return l},1/0);return i<1/0?r.map(l=>l.slice(i)).join(`
`):e},S=[/^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,/^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,/^#pragma ((?:end)?region) ([\w*-]+)$/,/^<!-- #?((?:end)?region) ([\w*-]+) -->$/,/^#((?:End )Region) ([\w*-]+)$/,/^::#((?:end)region) ([\w*-]+)$/,/^# ?((?:end)?region) ([\w*-]+)$/],I=/^( *)<!-{2,}\s*@include:\s*([^<>|:"*?]+(?:\.[a-z0-9]+))(?:#([\w-]+))?(?:\{(\d+)?-(\d+)?\})?\s*-{2,}>\s*$/gm,x=/^( *)@include:\s*([^<>|:"*?]+(?:\.[a-z0-9]+))(?:#([\w-]+))?(?:\{(\d+)?-(\d+)?\})?\s*$/gm,$=(e,r,i,l=!1)=>{const[s,n,t]=r.exec(e.trim())??[];return!!(s&&n&&t===i&&n.match(l?/^[Ee]nd ?[rR]egion$/:/^[rR]egion$/))},y=(e,r)=>{let i=null,l=-1;for(const[s,n]of e.entries())if(i===null){for(const t of S)if($(n,t,r)){l=s+1,i=t;break}}else if($(n,i,r,!0))return{lineStart:l,lineEnd:s};return null},w=(e,{cwd:r,includedFiles:i,resolvedPath:l})=>{const{filePath:s}=e;let n=s;if(!h.isAbsolute(s)){if(!r)return console.error(`[@mdit/plugin-include]: Error when resolving path: ${s}`),`
Error when resolving path
`;n=h.resolve(r,s)}if(i.push(n),!k.existsSync(n))return console.error(`[@mdit/plugin-include]: ${n} not found`),`
File not found
`;const t=k.readFileSync(n).toString().replace(b,`
`).split(`
`);let u=[];if("region"in e){const d=y(t,e.region);d&&(u=t.slice(d.lineStart,d.lineEnd))}else{const{lineStart:d,lineEnd:o}=e;if(d)u=t.slice(d-1,o);else if(t[0]==="---"){const c=t.findIndex((f,a)=>a!==0&&f==="---");u=t.slice(Math.max(c+1,1),o)}else u=t.slice(0,o)}if(l&&n.endsWith(".md")){const d=h.dirname(n);u.unshift(`<!-- #include-env-start: ${d} -->`),u.push("<!-- #include-env-end -->")}return E(u.join(`
`).replace(/\n?$/,`
`))},P=(e,r,{cwd:i,includedFiles:l})=>e.replace(r.useComment?I:x,(s,n,t,u,d,o)=>{const c=r.resolvePath(t,i),f=r.resolveImagePath||r.resolveLinkPath,a=w({filePath:c,...u?{region:u}:{...d?{lineStart:Number(d)}:{},...o?{lineEnd:Number(o)}:{}}},{cwd:i,includedFiles:l,resolvedPath:f});return(r.deep&&c.endsWith(".md")?P(a,r,{cwd:h.isAbsolute(c)?h.dirname(c):i?h.resolve(i,h.dirname(c)):null,includedFiles:l}):a).split(`
`).map(m=>n+m).join(`
`)}),F=/^<!-- #include-env-start: ([^)]*?) -->$/,A=(e,r,i,l)=>{const s=e.bMarks[r]+e.tShift[r],n=e.eMarks[r],t=e.src.slice(s,n);if(t.startsWith("<!-- #include-env-start: ")){const u=F.exec(t);if(u){if(l)return!0;const[,d]=u;e.line=r+1;const o=e.push("include_start","",0);return o.map=[r,e.line],o.info=d,o.markup="include_start",!0}}return!1},M=(e,r,i,l)=>{const s=e.bMarks[r]+e.tShift[r],n=e.eMarks[r];if(e.src.slice(s,n)==="<!-- #include-env-end -->"){if(l)return!0;e.line=r+1;const t=e.push("include_end","",0);return t.map=[r,e.line],t.markup="include_end",!0}return!1},_=(e,r,i,l)=>{const s=r.attrIndex(e),n=r.attrs?.[s][1];if(n?.[0]==="."&&Array.isArray(l)){const{length:t}=l;if(t){const u=h.relative(h.dirname(i),l[t-1]),d=h.join(u,n);r.attrs[s][1]=d?.[0]==="."?d:`./${d}`}}},R=(e,r)=>{const{currentPath:i,resolvePath:l=o=>o,deep:s=!1,resolveLinkPath:n=!0,resolveImagePath:t=!0,useComment:u=!0}=r??{};if(typeof i!="function")return console.error('[@mdit/plugin-include]: "currentPath" is required');const d=o=>{const c=o.env,f=c.includedFiles??=[],a=i(c);o.src=P(o.src,{currentPath:i,resolvePath:l,deep:s,resolveLinkPath:n,resolveImagePath:t,useComment:u},{cwd:a?h.dirname(a):null,includedFiles:f})};if(e.core.ruler.after("normalize","md_import",d),t||n){if(e.block.ruler.before("table","md_include_start",A,{alt:["paragraph","reference","blockquote","list"]}),e.block.ruler.before("table","md_include_end",M,{alt:["paragraph","reference","blockquote","list"]}),e.renderer.rules.include_start=(o,c,f,a)=>{const m=o[c];return(a.includedPaths??=[]).push(m.info),""},e.renderer.rules.include_end=(o,c,f,a)=>{const m=a.includedPaths;return Array.isArray(m)?m.pop():console.error("[@mdit/plugin-include]: include_end failed, no include_start."),""},t){const o=e.renderer.rules.image;e.renderer.rules.image=(c,f,a,m,p)=>{const v=c[f],g=i(m);return g&&_("src",v,g,m.includedPaths),o(c,f,a,m,p)}}if(n){const o=e.renderer.rules.link_open??((c,f,a,m,p)=>p.renderToken(c,f,a));e.renderer.rules.link_open=(c,f,a,m,p)=>{const v=c[f],g=i(m);return g&&_("href",v,g,m.includedPaths),o(c,f,a,m,p)}}}};export{w as handleInclude,R as include,P as resolveInclude};
//# sourceMappingURL=index.js.map
