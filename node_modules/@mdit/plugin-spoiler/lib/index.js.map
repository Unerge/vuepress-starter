{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-mark/blob/master/index.mjs\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\nimport type { Delimiter } from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItSpoilerOptions } from \"./options.js\";\n\n/*\n * Insert each marker as a separate text token, and add it to delimiter list\n *\n */\nconst tokenize: RuleInline = (state, silent) => {\n  const start = state.pos;\n  const marker = state.src.charAt(start);\n\n  if (silent || marker !== \"!\") return false;\n\n  const scanned = state.scanDelims(state.pos, true);\n  let { length } = scanned;\n\n  if (length < 2) return false;\n\n  if (length % 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = marker;\n    length--;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = `${marker}${marker}`;\n\n    if (scanned.can_open || scanned.can_close)\n      state.delimiters.push({\n        marker: 0x21,\n        length: 0, // disable \"rule of 3\" length checks meant for emphasis\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close,\n      });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n/*\n * Walk through delimiter list and replace text tokens with tags\n *\n */\nconst postProcess = (\n  state: StateInline,\n  delimiters: Delimiter[],\n  { tag, attrs }: Required<MarkdownItSpoilerOptions>,\n): void => {\n  let token;\n  const loneMarkers = [];\n  const max = delimiters.length;\n\n  for (let i = 0; i < max; i++) {\n    const startDelim = delimiters[i];\n\n    if (startDelim.marker === 0x21 /* ! */ && startDelim.end !== -1) {\n      const endDelim = delimiters[startDelim.end];\n\n      token = state.tokens[startDelim.token];\n      token.type = \"spoiler_open\";\n      token.tag = tag;\n      token.nesting = 1;\n      token.markup = \"!!\";\n      token.attrs = attrs;\n      token.content = \"\";\n\n      token = state.tokens[endDelim.token];\n      token.type = \"spoiler_close\";\n      token.tag = tag;\n      token.nesting = -1;\n      token.markup = \"!!\";\n      token.content = \"\";\n\n      if (\n        state.tokens[endDelim.token - 1].type === \"text\" &&\n        state.tokens[endDelim.token - 1].content === \"!\"\n      )\n        loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  /*\n   * If a marker sequence has an odd number of characters, itâ€™s splitted\n   * like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n   * start of the sequence.\n   *\n   * So, we have to move all those markers after subsequent s_close tags.\n   *\n   */\n  while (loneMarkers.length) {\n    const i = loneMarkers.pop()!;\n    let j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === \"spoiler_close\")\n      j++;\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\nexport const spoiler: PluginWithOptions<MarkdownItSpoilerOptions> = (\n  md,\n  {\n    tag = \"span\",\n    attrs = [\n      [\"class\", \"spoiler\"],\n      [\"tabindex\", \"-1\"],\n    ],\n  }: MarkdownItSpoilerOptions = {},\n) => {\n  md.inline.ruler.before(\"emphasis\", \"spoiler\", tokenize);\n  md.inline.ruler2.before(\"emphasis\", \"spoiler\", (state) => {\n    postProcess(state, state.delimiters, { tag, attrs });\n\n    for (const tokenMeta of state.tokens_meta ?? []) {\n      if (tokenMeta?.delimiters)\n        postProcess(state, tokenMeta.delimiters, { tag, attrs });\n    }\n\n    return true;\n  });\n};\n"],"names":["tokenize","state","silent","start","marker","scanned","length","token","i","postProcess","delimiters","tag","attrs","loneMarkers","max","startDelim","endDelim","j","spoiler","md","tokenMeta"],"mappings":"AAeA,MAAMA,EAAuB,CAACC,EAAOC,IAAW,CAC9C,MAAMC,EAAQF,EAAM,IACdG,EAASH,EAAM,IAAI,OAAOE,CAAK,EAErC,GAAID,GAAUE,IAAW,IAAK,MAAO,GAErC,MAAMC,EAAUJ,EAAM,WAAWA,EAAM,IAAK,EAAI,EAChD,GAAI,CAAE,OAAAK,CAAO,EAAID,EAEjB,GAAIC,EAAS,EAAG,MAAO,GAEvB,GAAIA,EAAS,EAAG,CACd,MAAMC,EAAQN,EAAM,KAAK,OAAQ,GAAI,CAAC,EAEtCM,EAAM,QAAUH,EAChBE,GACF,CAEA,QAASE,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAAG,CAClC,MAAMD,EAAQN,EAAM,KAAK,OAAQ,GAAI,CAAC,EAEtCM,EAAM,QAAU,GAAGH,CAAM,GAAGA,CAAM,IAE9BC,EAAQ,UAAYA,EAAQ,YAC9BJ,EAAM,WAAW,KAAK,CACpB,OAAQ,GACR,OAAQ,EACR,MAAOA,EAAM,OAAO,OAAS,EAC7B,IAAK,GACL,KAAMI,EAAQ,SACd,MAAOA,EAAQ,SACjB,CAAC,CACL,CAEA,OAAAJ,EAAM,KAAOI,EAAQ,OAEd,EACT,EAMMI,EAAc,CAClBR,EACAS,EACA,CAAE,IAAAC,EAAK,MAAAC,CAAM,IACJ,CACT,IAAIL,EACJ,MAAMM,EAAc,CAAC,EACfC,EAAMJ,EAAW,OAEvB,QAASF,EAAI,EAAGA,EAAIM,EAAKN,IAAK,CAC5B,MAAMO,EAAaL,EAAWF,CAAC,EAE/B,GAAIO,EAAW,SAAW,IAAgBA,EAAW,MAAQ,GAAI,CAC/D,MAAMC,EAAWN,EAAWK,EAAW,GAAG,EAE1CR,EAAQN,EAAM,OAAOc,EAAW,KAAK,EACrCR,EAAM,KAAO,eACbA,EAAM,IAAMI,EACZJ,EAAM,QAAU,EAChBA,EAAM,OAAS,KACfA,EAAM,MAAQK,EACdL,EAAM,QAAU,GAEhBA,EAAQN,EAAM,OAAOe,EAAS,KAAK,EACnCT,EAAM,KAAO,gBACbA,EAAM,IAAMI,EACZJ,EAAM,QAAU,GAChBA,EAAM,OAAS,KACfA,EAAM,QAAU,GAGdN,EAAM,OAAOe,EAAS,MAAQ,CAAC,EAAE,OAAS,QAC1Cf,EAAM,OAAOe,EAAS,MAAQ,CAAC,EAAE,UAAY,KAE7CH,EAAY,KAAKG,EAAS,MAAQ,CAAC,CACvC,CACF,CAUA,KAAOH,EAAY,QAAQ,CACzB,MAAML,EAAIK,EAAY,MACtB,IAAII,EAAIT,EAAI,EAEZ,KAAOS,EAAIhB,EAAM,OAAO,QAAUA,EAAM,OAAOgB,CAAC,EAAE,OAAS,iBACzDA,IAEFA,IAEIT,IAAMS,IACRV,EAAQN,EAAM,OAAOgB,CAAC,EACtBhB,EAAM,OAAOgB,CAAC,EAAIhB,EAAM,OAAOO,CAAC,EAChCP,EAAM,OAAOO,CAAC,EAAID,EAEtB,CACF,EAEaW,EAAuD,CAClEC,EACA,CACE,IAAAR,EAAM,OACN,MAAAC,EAAQ,CACN,CAAC,QAAS,SAAS,EACnB,CAAC,WAAY,IAAI,CACnB,CACF,EAA8B,CAC3B,IAAA,CACHO,EAAG,OAAO,MAAM,OAAO,WAAY,UAAWnB,CAAQ,EACtDmB,EAAG,OAAO,OAAO,OAAO,WAAY,UAAYlB,GAAU,CACxDQ,EAAYR,EAAOA,EAAM,WAAY,CAAE,IAAAU,EAAK,MAAAC,CAAM,CAAC,EAEnD,UAAWQ,KAAanB,EAAM,aAAe,CAAA,EACvCmB,GAAW,YACbX,EAAYR,EAAOmB,EAAU,WAAY,CAAE,IAAAT,EAAK,MAAAC,CAAM,CAAC,EAG3D,MAAO,EACT,CAAC,CACH"}