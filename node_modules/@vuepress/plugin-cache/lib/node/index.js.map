{"version":3,"file":"index.js","sources":["../../src/node/highlightCache.ts","../../src/node/utils.ts","../../src/node/renderCache.ts","../../src/node/cachePlugin.ts"],"sourcesContent":["/**\n * Code highlight is a relatively time-consuming operation,\n * especially in `shiki` where enabling numerous transformers can significantly impact performance.\n * This effect is particularly noticeable with tools like `twoslash`,\n * which require type compilation and may lead to individual code blocks taking over 500ms to process.\n *\n * When there are multiple code blocks, focusing only on modifying parts of the code blocks while\n * still compiling all code blocks entirely can lead to unnecessary overhead.\n * Therefore, using the LRU cache algorithm can help by storing unchanged code blocks'\n * highlighted results and only processing the parts that have been modified.\n */\nimport { LRUCache } from 'lru-cache'\nimport type { App } from 'vuepress'\nimport type { Markdown } from 'vuepress/markdown'\nimport { hash } from 'vuepress/utils'\n\nconst cache = new LRUCache<string, string>({ max: 64 })\n\nexport const highlightCache = (md: Markdown, app: App): void => {\n  /**\n   * Cache is only needed in development mode to enhance the development experience.\n   */\n  if (!app.env.isDev) return\n\n  const { highlight } = md.options\n\n  md.options.highlight = (...args) => {\n    const key = hash(args.join(''))\n    const cached = cache.get(key)\n\n    if (cached) return cached\n\n    const content = highlight?.(...args) ?? ''\n    cache.set(key, content)\n\n    return content\n  }\n}\n","import { fs, path } from 'vuepress/utils'\n\nexport const readFile = async <T = unknown>(\n  filepath: string,\n): Promise<T | null> => {\n  try {\n    return (await fs.readJSON(filepath, 'utf-8')) as T\n  } catch {\n    return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport const readFileSync = <T = unknown>(filepath: string): T | null => {\n  try {\n    return fs.readJSONSync(filepath, 'utf-8') as T\n  } catch {\n    return null\n  }\n}\n\nexport const writeFile = (filepath: string, data: unknown): Promise<void> =>\n  fs.writeJSON(filepath, data, 'utf-8')\n\nconst FALLBACK_SPEED = 0.15\n\nexport const checkIOSpeed = (cwd = process.cwd()): number => {\n  try {\n    const tmp = path.join(cwd, 'tmp')\n    fs.writeFileSync(tmp, '{}', 'utf-8')\n    const start = performance.now()\n    readFileSync(tmp)\n    const end = performance.now()\n    fs.unlinkSync(tmp)\n    return end - start\n  } catch {\n    return FALLBACK_SPEED\n  }\n}\n","/**\n * When various features are added to markdown, the compilation speed of a single markdown file\n * will become slower, especially when there are many pages in the project,\n * causing the startup of the vuepress development service to become very slow and time-consuming.\n * This plugin will cache the `markdown render` result during the initial compilation process.\n * During subsequent compilations, if the content has not been modified,\n * compilation will be skipped directly, thus speeding up the second startup of vuepress.\n */\nimport type { App } from 'vuepress'\nimport type { Markdown, MarkdownEnv } from 'vuepress/markdown'\nimport { fs, hash } from 'vuepress/utils'\nimport { checkIOSpeed, readFile, readFileSync, writeFile } from './utils.js'\n\nexport interface CacheData {\n  content: string\n  env: MarkdownEnv\n}\n\n// { [filepath]: CacheDta }\nexport type Cache = Record<string, CacheData>\n\n// { [filepath]: hash }\nexport type Metadata = Record<string, string>\n\nconst CACHE_DIR = 'markdown/rendered'\nconst META_FILE = '_metadata.json'\nconst CACHE_FILE = '_cache.json'\n\nexport const renderCacheWithMemory = async (\n  md: Markdown,\n  app: App,\n): Promise<void> => {\n  if (app.env.isBuild && !fs.existsSync(app.dir.cache(CACHE_DIR))) {\n    return\n  }\n\n  const basename = app.dir.cache(CACHE_DIR)\n  const metaFilepath = `${basename}/${META_FILE}`\n  const cacheFilepath = `${basename}/${CACHE_FILE}`\n\n  await fs.ensureDir(basename)\n\n  const [metadata, cache] = await Promise.all([\n    readFile<Metadata>(metaFilepath),\n    readFile<Cache>(cacheFilepath),\n  ]).then(\n    ([metadataStore, cacheStore]) =>\n      [metadataStore ?? {}, cacheStore ?? {}] as const,\n  )\n\n  let timer: ReturnType<typeof setTimeout> | null = null\n\n  const update = (): void => {\n    if (timer) clearTimeout(timer)\n\n    timer = setTimeout(() => {\n      void Promise.all([\n        writeFile(metaFilepath, metadata),\n        writeFile(cacheFilepath, cache),\n      ])\n    }, 200)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const rawRender = md.render\n  md.render = (input, env: MarkdownEnv) => {\n    const filepath = env.filePathRelative\n\n    if (!filepath) {\n      return rawRender(input, env)\n    }\n\n    const key = hash(input)\n\n    if (metadata[filepath] === key && filepath in cache) {\n      const cached = cache[filepath]\n      Object.assign(env, cached.env)\n      return cached.content\n    }\n\n    const content = rawRender(input, env)\n    metadata[filepath] = key\n    cache[filepath] = { content, env }\n\n    update()\n\n    return content\n  }\n}\n\nexport const renderCacheWithFilesystem = async (\n  md: Markdown,\n  app: App,\n): Promise<void> => {\n  if (app.env.isBuild && !fs.existsSync(app.dir.cache(CACHE_DIR))) {\n    return\n  }\n  const basename = app.dir.cache(CACHE_DIR)\n\n  await fs.ensureDir(basename)\n\n  const speed = checkIOSpeed(basename)\n\n  const metaFilepath = `${basename}/${META_FILE}`\n\n  const metadata = (await readFile<Metadata>(metaFilepath)) ?? {}\n\n  let timer: ReturnType<typeof setTimeout> | null = null\n\n  const update = (filepath: string, data: CacheData): void => {\n    void writeFile(`${basename}/${filepath}`, data)\n\n    if (timer) clearTimeout(timer)\n\n    timer = setTimeout(() => {\n      void writeFile(metaFilepath, metadata)\n    }, 200)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const rawRender = md.render\n\n  md.render = (input, env: MarkdownEnv) => {\n    const filepath = env.filePathRelative\n\n    if (!filepath) {\n      return rawRender(input, env)\n    }\n\n    const key = hash(input)\n    const filename = hash(filepath)\n\n    if (metadata[filepath] === key) {\n      const cached = readFileSync<CacheData>(`${basename}/${filename}`)\n      if (cached) {\n        Object.assign(env, cached.env)\n        return cached.content\n      }\n      metadata[filepath] = ''\n    }\n    const start = performance.now()\n    const content = rawRender(input, env)\n\n    /**\n     * High-frequency I/O is also a time-consuming operation,\n     * therefore, for render operations with low overhead, caching is not performed.\n     */\n    if (performance.now() - start > speed) {\n      metadata[filepath] = key\n      update(filename, { content, env })\n    }\n    return content\n  }\n}\n","import ci from 'ci-info'\nimport type { Plugin } from 'vuepress/core'\nimport { highlightCache } from './highlightCache.js'\nimport {\n  renderCacheWithFilesystem,\n  renderCacheWithMemory,\n} from './renderCache.js'\n\nexport interface CachePluginOptions {\n  /**\n   * Cache type\n   *\n   * - Using memory caching can achieve the best optimization effects, but the cost increases as the project grows, occupying more content, suitable for projects with fewer pages.\n   * - For complex projects with many pages, it is recommended to use file caching.\n   *\n   * @default 'memory'\n   */\n  type?: 'filesystem' | 'memory'\n\n  /**\n   * Whether to enable the cache in CI environment.\n   *\n   * @default false\n   */\n  enableInCi?: boolean\n}\n/**\n * Cache markdown rendering, optimize compilation speed.\n *\n * This plugin is recommended to be placed after all other plugins to ensure maximum utilization of the cache.\n */\nexport const cachePlugin = ({\n  type,\n  enableInCi = false,\n}: CachePluginOptions = {}): Plugin => {\n  const plugin: Plugin = {\n    name: '@vuepress/plugin-cache',\n  }\n\n  if (ci.isCI && !enableInCi) {\n    return plugin\n  }\n\n  return {\n    ...plugin,\n\n    async extendsMarkdown(md, app) {\n      highlightCache(md, app)\n      if (type === 'filesystem') {\n        await renderCacheWithFilesystem(md, app)\n      } else {\n        await renderCacheWithMemory(md, app)\n      }\n    },\n  }\n}\n"],"names":["cache","LRUCache","highlightCache","md","app","highlight","args","key","hash","cached","content","readFile","filepath","fs","readFileSync","writeFile","data","FALLBACK_SPEED","checkIOSpeed","cwd","tmp","path","start","end","CACHE_DIR","META_FILE","CACHE_FILE","renderCacheWithMemory","basename","metaFilepath","cacheFilepath","metadata","metadataStore","cacheStore","timer","update","rawRender","input","env","renderCacheWithFilesystem","speed","filename","cachePlugin","type","enableInCi","plugin","ci"],"mappings":"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"}