// src/node/shikiPlugin.ts
import { isPlainObject as isPlainObject2 } from "vuepress/shared";
import { colors } from "vuepress/utils";

// src/node/copy-code-button/copyCodeButtonLocales.ts
var copyCodeButtonLocales = {
  "/en/": {
    title: "Copy code",
    copied: "Copied"
  },
  "/zh/": {
    title: "\u590D\u5236\u4EE3\u7801",
    copied: "\u5DF2\u590D\u5236"
  },
  "/zh-tw/": {
    title: "\u8907\u88FD\u4EE3\u78BC",
    copied: "\u5DF2\u8907\u88FD"
  },
  "/de/": {
    title: "Kopiere den Code.",
    copied: "Kopiert"
  },
  "/de-at/": {
    title: "Kopiere den Code.",
    copied: "Kopierter"
  },
  "/vi/": {
    title: "Sao ch\xE9p code",
    copied: "\u0110\xE3 sao ch\xE9p"
  },
  "/uk/": {
    title: "\u0421\u043A\u043E\u043F\u0456\u044E\u0439\u0442\u0435 \u043A\u043E\u0434",
    copied: "\u0421\u043A\u043E\u043F\u0456\u0439\u043E\u0432\u0430\u043D\u043E"
  },
  "/ru/": {
    title: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u043E\u0434",
    copied: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E"
  },
  "/br/": {
    title: "Copiar o c\xF3digo",
    copied: "C\xF3digo"
  },
  "/pl/": {
    title: "Skopiuj kod",
    copied: "Skopiowane"
  },
  "/sk/": {
    title: "Skop\xEDruj k\xF3d",
    copied: "Skop\xEDrovan\xE9"
  },
  "/fr/": {
    title: "Copier le code",
    copied: "Copi\xE9"
  },
  "/es/": {
    title: "Copiar c\xF3digo",
    copied: "Copiado"
  },
  "/ja/": {
    title: "\u30B3\u30FC\u30C9\u3092\u30B3\u30D4\u30FC",
    copied: "\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F"
  },
  "/tr/": {
    title: "Kodu kopyala",
    copied: "Kopyaland\u0131"
  },
  "/ko/": {
    title: "\uCF54\uB4DC \uBCF5\uC0AC",
    copied: "\uBCF5\uC0AC\uB428"
  },
  "/fi/": {
    title: "Kopioi koodi",
    copied: "Kopioitu"
  },
  "/hu/": {
    title: "K\xF3d m\xE1sol\xE1sa",
    copied: "M\xE1solva"
  },
  "/id/": {
    title: "Salin kode",
    copied: "Disalin"
  },
  "/nl/": {
    title: "Kopieer code",
    copied: "Gekopieerd"
  }
};

// src/node/copy-code-button/createCopyCodeButtonRender.ts
import {
  getLocalePaths,
  getRootLangPath,
  isPlainObject
} from "@vuepress/helper";
import { ensureLeadingSlash, resolveLocalePath } from "vuepress/shared";
function createCopyCodeButtonRender(app, options) {
  if (options === false)
    return null;
  const { className = "copy", locales: userLocales = {} } = isPlainObject(options) ? options : {};
  const root = getRootLangPath(app);
  const locales = {
    // fallback locale
    "/": userLocales["/"] || copyCodeButtonLocales[root]
  };
  getLocalePaths(app).forEach((path3) => {
    locales[path3] = userLocales[path3] || copyCodeButtonLocales[path3 === "/" ? root : path3];
  });
  return (filePathRelative) => {
    const relativePath = ensureLeadingSlash(filePathRelative);
    const localePath = resolveLocalePath(locales, relativePath);
    const { title, copied } = locales[localePath];
    return `<button class="${className}" title="${title}" data-copied="${copied}"></button>`;
  };
}

// src/node/copy-code-button/copyCodeButtonPlugin.ts
function copyCodeButtonPlugin(md, app, options) {
  const render = createCopyCodeButtonRender(app, options);
  if (!render)
    return;
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [, , , env] = args;
    const result = fence(...args);
    const { filePathRelative } = env;
    const copyCodeButton = render(filePathRelative ?? "");
    return result.replace("><pre", `>${copyCodeButton}<pre`);
  };
}

// src/node/highlight/highlight.ts
import { customAlphabet } from "nanoid";
import { bundledLanguages, createHighlighter } from "shiki";
import { logger as logger3 } from "vuepress/utils";

// src/node/highlight/getLanguage.ts
import { isPlainLang, isSpecialLang } from "shiki";
import { colors as c, logger as logger2 } from "vuepress/utils";

// src/node/utils/index.ts
import { Logger } from "@vuepress/helper";

// src/node/utils/attrsToLines.ts
function attrsToLines(attrs) {
  attrs = attrs.replace(/^(?:\[.*?\])?.*?([\d,-]+).*/, "$1").trim();
  const result = [];
  if (!attrs)
    return [];
  attrs.split(",").map((v) => v.split("-").map((v2) => Number.parseInt(v2, 10))).forEach(([start, end]) => {
    if (start && end) {
      result.push(
        ...Array.from({ length: end - start + 1 }, (_, i) => start + i)
      );
    } else {
      result.push(start);
    }
  });
  return result.map((line) => ({
    line,
    classes: ["highlighted"]
  }));
}

// src/node/utils/collapsedLines.ts
var COLLAPSED_LINES_REGEXP = /:collapsed-lines\b/;
var COLLAPSED_LINES_START_REGEXP = /:collapsed-lines=(\d+)\b/;
var NO_COLLAPSED_LINES_REGEXP = /:no-collapsed-lines\b/;
function resolveCollapsedLines(info) {
  const lines = COLLAPSED_LINES_START_REGEXP.exec(info)?.[1];
  if (lines) {
    return Number(lines);
  }
  if (COLLAPSED_LINES_REGEXP.test(info)) {
    return true;
  }
  if (NO_COLLAPSED_LINES_REGEXP.test(info)) {
    return false;
  }
  return null;
}

// src/node/utils/resolveAttr.ts
function resolveAttr(info, attr) {
  const pattern = `\\b${attr}\\s*=\\s*(?<quote>['"])(?<content>.+?)\\k<quote>(\\s|$)`;
  const regex = new RegExp(pattern, "i");
  const match = info.match(regex);
  return match?.groups?.content ?? null;
}

// src/node/utils/resolveLanguage.ts
var VUE_RE = /-vue$/;
function resolveLanguage(info) {
  return info.match(/^([^ :[{]+)/)?.[1]?.replace(VUE_RE, "").toLowerCase() ?? "";
}

// src/node/utils/whitespace.ts
var WHITESPACE_REGEXP = /:whitespace(?:=(all|boundary|trailing)?)?\b/;
var NO_WHITESPACE_REGEXP = /:no-whitespace\b/;
function resolveWhitespacePosition(info, defaultPosition) {
  if (NO_WHITESPACE_REGEXP.test(info)) {
    return false;
  }
  defaultPosition = defaultPosition === true ? void 0 : defaultPosition;
  const match = info.match(WHITESPACE_REGEXP);
  if (match) {
    return match[1] || defaultPosition || "all";
  }
  return defaultPosition ?? false;
}

// src/node/utils/index.ts
var logger = new Logger("@vuepress-plume/plugin-shikiji");

// src/node/highlight/getLanguage.ts
function getLanguage(loadedLanguages, language, defaultLang) {
  let lang = resolveLanguage(language) || defaultLang;
  if (lang) {
    const langLoaded = loadedLanguages.includes(lang);
    if (!langLoaded && !isPlainLang(lang) && !isSpecialLang(lang)) {
      logger2.warn(
        c.yellow(
          `
The language '${lang}' is not loaded, falling back to '${defaultLang || "txt"}' for syntax highlighting.`
        )
      );
      lang = defaultLang;
    }
  }
  return lang;
}

// src/node/highlight/transformers.ts
import {
  transformerCompactLineOptions,
  transformerNotationDiff,
  transformerNotationErrorLevel,
  transformerNotationFocus,
  transformerNotationHighlight,
  transformerNotationWordHighlight,
  transformerRemoveNotationEscape,
  transformerRenderWhitespace
} from "@shikijs/transformers";
import { addClassToHast } from "shiki";

// src/node/twoslash/rendererTransformer.ts
import process from "node:process";
import { createTransformerFactory } from "@shikijs/twoslash/core";
import { removeTwoslashNotations } from "twoslash";
import { createTwoslasher } from "twoslash-vue";

// src/node/twoslash/renderer-floating-vue.ts
import { defaultHoverInfoProcessor, rendererRich } from "@shikijs/twoslash";
import { fromMarkdown } from "mdast-util-from-markdown";
import { gfmFromMarkdown } from "mdast-util-gfm";
import { defaultHandlers, toHast } from "mdast-util-to-hast";
function rendererFloatingVue(options = {}) {
  const {
    classCopyIgnore = "vp-copy-ignore",
    classFloatingPanel = "twoslash-floating",
    classCode = "vp-code",
    classMarkdown = "vp-doc",
    floatingVueTheme = "twoslash",
    floatingVueThemeQuery = "twoslash-query",
    floatingVueThemeCompletion = "twoslash-completion"
  } = options.floatingVue || {};
  const {
    errorRendering = "line"
  } = options;
  const hoverBasicProps = {
    "class": "twoslash-hover",
    "popper-class": ["shiki", classFloatingPanel, classCopyIgnore, classCode].join(" "),
    "theme": floatingVueTheme
  };
  const rich = rendererRich({
    classExtra: classCopyIgnore,
    ...options,
    renderMarkdown,
    renderMarkdownInline,
    hast: {
      hoverToken: {
        tagName: "v-menu",
        properties: hoverBasicProps
      },
      hoverCompose: compose,
      queryToken: {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          ":shown": "true",
          "theme": floatingVueThemeQuery
        }
      },
      queryCompose: compose,
      popupDocs: {
        class: `twoslash-popup-docs ${classMarkdown}`
      },
      popupDocsTags: {
        class: `twoslash-popup-docs twoslash-popup-docs-tags ${classMarkdown}`
      },
      popupError: {
        class: `twoslash-popup-error ${classMarkdown}`
      },
      errorToken: errorRendering === "line" ? void 0 : {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          class: "twoslash-error twoslash-error-hover"
        }
      },
      errorCompose: compose,
      completionCompose({ popup, cursor }) {
        return [
          {
            type: "element",
            tagName: "v-menu",
            properties: {
              "popper-class": ["shiki twoslash-completion", classCopyIgnore, classFloatingPanel],
              "theme": floatingVueThemeCompletion,
              ":shown": "true"
            },
            children: [
              cursor,
              {
                type: "element",
                tagName: "template",
                properties: {
                  "v-slot:popper": "{}"
                },
                content: {
                  type: "root",
                  children: [vPre(popup)]
                }
              }
            ]
          }
        ];
      }
    }
  });
  return rich;
}
function compose(parts) {
  return [
    {
      type: "element",
      tagName: "span",
      properties: {},
      children: [parts.token]
    },
    {
      type: "element",
      tagName: "template",
      properties: {
        "v-slot:popper": "{}"
      },
      content: {
        type: "root",
        children: [vPre(parts.popup)]
      },
      children: []
    }
  ];
}
function vPre(el) {
  if (el.type === "element") {
    el.properties = el.properties || {};
    el.properties["v-pre"] = "";
  }
  return el;
}
function renderMarkdown(md) {
  const mdast = fromMarkdown(
    md.replace(/\{@link ([^}]*)\}/g, "$1"),
    // replace jsdoc links
    { mdastExtensions: [gfmFromMarkdown()] }
  );
  return toHast(
    mdast,
    {
      handlers: {
        code: (state, node) => {
          const lang = node.lang || "";
          if (lang) {
            return {
              type: "element",
              tagName: "code",
              properties: {},
              children: this.codeToHast(
                node.value,
                {
                  ...this.options,
                  transformers: [],
                  lang,
                  structure: node.value.trim().includes("\n") ? "classic" : "inline"
                }
              ).children
            };
          }
          return defaultHandlers.code(state, node);
        }
      }
    }
  ).children;
}
function renderMarkdownInline(md, context) {
  if (context === "tag:param")
    md = md.replace(/^([\w$-]+)/, "`$1` ");
  const children = renderMarkdown.call(this, md);
  if (children.length === 1 && children[0].type === "element" && children[0].tagName === "p")
    return children[0].children;
  return children;
}

// src/node/twoslash/rendererTransformer.ts
function transformerTwoslash(options = {}) {
  const {
    explicitTrigger = true
  } = options;
  const onError = (error, code) => {
    const isCI = typeof process !== "undefined" && process?.env?.CI;
    const isDev = typeof process !== "undefined" && process?.env?.NODE_ENV === "development";
    const shouldThrow = (options.throws || isCI || !isDev) && options.throws !== false;
    console.error(`

--------
Twoslash error in code:
--------
${code.split(/\n/g).slice(0, 15).join("\n").trim()}
--------
`);
    if (shouldThrow)
      throw error;
    else
      console.error(error);
    return removeTwoslashNotations(code);
  };
  const twoslash = createTransformerFactory(
    createTwoslasher(options.twoslashOptions)
  )({
    langs: ["ts", "tsx", "js", "jsx", "json", "vue"],
    renderer: rendererFloatingVue(options),
    onTwoslashError: onError,
    onShikiError: onError,
    ...options,
    explicitTrigger
  });
  const trigger = explicitTrigger instanceof RegExp ? explicitTrigger : /\btwoslash\b/;
  return {
    ...twoslash,
    name: "@shiki/vuepress-twoslash",
    preprocess(code, options2) {
      const cleanup = options2.transformers?.find((i) => i.name === "vuepress:clean-up");
      if (cleanup)
        options2.transformers?.splice(options2.transformers.indexOf(cleanup), 1);
      if (!explicitTrigger || options2.meta?.__raw?.match(trigger)) {
        const vPre2 = options2.transformers?.find((i) => i.name === "vitepress:v-pre");
        if (vPre2)
          options2.transformers?.splice(options2.transformers.indexOf(vPre2), 1);
      }
      return twoslash.preprocess.call(this, code, options2);
    },
    postprocess(html) {
      if (this.meta.twoslash)
        return html.replace(/\{/g, "&#123;");
      return html;
    }
  };
}

// src/node/highlight/transformers.ts
var decorationsRE = /^\/\/ @decorations:(.*)\n/;
var baseTransformers = [
  transformerNotationDiff(),
  transformerNotationFocus({
    classActiveLine: "has-focus",
    classActivePre: "has-focused-lines"
  }),
  transformerNotationHighlight(),
  transformerNotationErrorLevel(),
  transformerNotationWordHighlight(),
  {
    name: "vuepress:add-class",
    pre(node) {
      addClassToHast(node, "vp-code");
    }
  },
  {
    name: "vuepress:clean-up",
    pre(node) {
      delete node.properties.tabindex;
      delete node.properties.style;
    }
  },
  {
    name: "shiki:inline-decorations",
    preprocess(code, options) {
      code = code.replace(decorationsRE, (match, decorations) => {
        options.decorations ||= [];
        options.decorations.push(...JSON.parse(decorations));
        return "";
      });
      return code;
    }
  },
  transformerRemoveNotationEscape()
];
var vueRE = /-vue$/;
function getInlineTransformers({ attrs, lang, enabledTwoslash, whitespace }) {
  const vPre2 = vueRE.test(lang) ? "" : "v-pre";
  const inlineTransformers = [
    transformerCompactLineOptions(attrsToLines(attrs))
  ];
  if (enabledTwoslash) {
    inlineTransformers.push(transformerTwoslash({
      processHoverInfo(info) {
        return defaultHoverInfoProcessor(info);
      }
    }));
  } else {
    inlineTransformers.push({
      name: "vuepress:v-pre",
      pre(node) {
        if (vPre2)
          node.properties["v-pre"] = "";
      }
    });
  }
  const position = resolveWhitespacePosition(attrs, whitespace);
  if (position)
    inlineTransformers.push(transformerRenderWhitespace({ position }));
  return inlineTransformers;
}

// src/node/highlight/highlight.ts
var nanoid = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
var mustacheRE = /\{\{.*?\}\}/g;
async function highlight(theme, options) {
  const {
    defaultHighlightLang: defaultLang = "",
    codeTransformers: userTransformers = [],
    whitespace = false,
    languages: languages2 = Object.keys(bundledLanguages)
  } = options;
  const highlighter = await createHighlighter({
    themes: typeof theme === "object" && "light" in theme && "dark" in theme ? [theme.light, theme.dark] : [theme],
    langs: languages2,
    langAlias: options.languageAlias
  });
  await options.shikiSetup?.(highlighter);
  const loadedLanguages = highlighter.getLoadedLanguages();
  return (str, language, attrs = "") => {
    const lang = getLanguage(loadedLanguages, language, defaultLang);
    const enabledTwoslash = attrs.includes("twoslash") && !!options.twoslash;
    const mustaches = /* @__PURE__ */ new Map();
    str = removeMustache(str, mustaches).trimEnd();
    try {
      const highlighted = highlighter.codeToHtml(str, {
        lang,
        transformers: [
          ...baseTransformers,
          ...getInlineTransformers({ attrs, lang, enabledTwoslash, whitespace }),
          ...userTransformers
        ],
        meta: { __raw: attrs },
        ...typeof theme === "object" && "light" in theme && "dark" in theme ? { themes: theme, defaultColor: false } : { theme }
      });
      const rendered = restoreMustache(highlighted, mustaches, enabledTwoslash);
      return rendered;
    } catch (e) {
      logger3.error(e);
      return str;
    }
  };
}
function removeMustache(s, mustaches) {
  return s.replace(mustacheRE, (match) => {
    let marker = mustaches.get(match);
    if (!marker) {
      marker = nanoid();
      mustaches.set(match, marker);
    }
    return marker;
  });
}
function restoreMustache(s, mustaches, twoslash) {
  mustaches.forEach((marker, match) => {
    s = s.replaceAll(marker, match);
  });
  if (twoslash)
    s = s.replace(/\{/g, "&#123;");
  return `${s}
`;
}

// src/node/highlight/scanLanguages.ts
import fs from "node:fs/promises";
import path from "node:path";
import fg from "fast-glob";
import { bundledLanguages as bundledLanguages2 } from "shiki";
var languages = Object.keys(bundledLanguages2);
var RE_FENCE = /`{3,}[^`]*?(\s|$)/g;
async function scanLanguages(app) {
  const source = app.dir.source();
  const pattern = ["**/*.md", "!.vuepress", "!node_modules"];
  const files = await fg(pattern, {
    cwd: source
  });
  const langs = /* @__PURE__ */ new Set();
  for (const file of files) {
    const filepath = path.join(source, file);
    const content = await fs.readFile(filepath, "utf-8");
    const matched = content.match(RE_FENCE);
    if (matched) {
      for (const match of matched) {
        let lang = match.replace(/`{3,}/, "").trim();
        if (lang.includes(":"))
          lang = lang.split(":")[0];
        if (lang)
          langs.add(lang);
      }
    }
  }
  return Array.from(langs).filter((lang) => languages.includes(lang));
}

// src/node/markdown/collapsedLinesPlugin.ts
function collapsedLinesPlugin(md, {
  collapsedLines: collapsedLinesOptions = false
} = {}) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, index] = args;
    const token = tokens[index];
    const info = token.info ? md.utils.unescapeAll(token.info).trim() : "";
    const code = rawFence(...args);
    const collapsedLinesInfo = resolveCollapsedLines(info) ?? collapsedLinesOptions;
    if (collapsedLinesInfo === false) {
      return code;
    }
    const lines = code.slice(code.indexOf("<code>"), code.indexOf("</code>")).split("\n").length;
    const startLines = typeof collapsedLinesInfo === "number" ? collapsedLinesInfo : 15;
    if (lines < startLines) {
      return code;
    }
    const collapsedLinesCode = `<div class="collapsed-lines"></div>`;
    const styles = `--vp-collapsed-lines:${startLines};`;
    const finalCode = code.replace(/<\/div>$/, `${collapsedLinesCode}</div>`).replace(/"(language-[^"]*)"/, '"$1 has-collapsed collapsed"').replace(/^<div[^>]*>/, (match) => {
      if (!match.includes("style=")) {
        return `${match.slice(0, -1)} style="${styles}">`;
      }
      return match.replace(/(style=")/, `$1${styles}`);
    });
    return finalCode;
  };
}

// src/node/markdown/highlightLinesPlugin.ts
var HIGHLIGHT_LINES_REGEXP = /\{([\d,-]+)\}/;
function highlightLinesPlugin(md) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx] = args;
    const token = tokens[idx];
    let lines = null;
    const rawInfo = token.info;
    const result = rawInfo?.match(HIGHLIGHT_LINES_REGEXP);
    if (!result)
      return rawFence(...args);
    token.info = rawInfo.replace(HIGHLIGHT_LINES_REGEXP, "").trim();
    lines = result[1];
    token.info += ` ${lines}`;
    return rawFence(...args);
  };
}

// src/node/markdown/lineNumberPlugin.ts
var LINE_NUMBERS_REGEXP = /:line-numbers\b/;
var NO_LINE_NUMBERS_REGEXP = /:no-line-numbers\b/;
var LINE_NUMBERS_START_REGEXP = /:line-numbers=(\d+)\b/;
function lineNumberPlugin(md, { lineNumbers = true } = {}) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const rawCode = rawFence(...args);
    const [tokens, idx] = args;
    const info = tokens[idx].info;
    const enableLineNumbers = LINE_NUMBERS_REGEXP.test(info);
    const disableLineNumbers = NO_LINE_NUMBERS_REGEXP.test(info);
    if (info.includes("twoslash"))
      return rawCode;
    if (!lineNumbers && !enableLineNumbers || lineNumbers && disableLineNumbers) {
      return rawCode;
    }
    const code = rawCode.slice(
      rawCode.indexOf("<code>"),
      rawCode.indexOf("</code>")
    );
    const lines = code.split("\n");
    if (typeof lineNumbers === "number" && lines.length < lineNumbers && !enableLineNumbers) {
      return rawCode;
    }
    const startNumbers = Number(info.match(LINE_NUMBERS_START_REGEXP)?.[1] ?? 1) - 1;
    const lineNumbersStyle = `style="counter-reset:line-number ${startNumbers}"`;
    const lineNumbersCode = [...Array.from({ length: lines.length })].map(() => `<div class="line-number"></div>`).join("");
    const lineNumbersWrapperCode = `<div class="line-numbers" aria-hidden="true" ${lineNumbersStyle}>${lineNumbersCode}</div>`;
    const finalCode = rawCode.replace(/<\/div>$/, `${lineNumbersWrapperCode}</div>`).replace(/"(language-[^"]*)"/, '"$1 line-numbers-mode"');
    return finalCode;
  };
}

// src/node/markdown/preWrapperPlugin.ts
function preWrapperPlugin(md, { preWrapper = true } = {}) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx, options] = args;
    const token = tokens[idx];
    const info = token.info ? md.utils.unescapeAll(token.info).trim() : "";
    const lang = resolveLanguage(info);
    const title = resolveAttr(info, "title") || lang;
    const classes = [`${options.langPrefix}${lang}`];
    let result = rawFence(...args);
    if (!preWrapper) {
      result = result.replace(/<code[\s\S]*?>/, "<code>");
      result = `<pre class="${classes.join(" ")}"${result.slice("<pre".length)}`;
      return result;
    }
    const attrs = [
      `data-ext="${lang}"`,
      `data-title="${title}"`
    ];
    return `<div class="${classes.join(" ")}" ${attrs.join(" ")}>${result}</div>`;
  };
}

// src/node/prepareClientConfigFile.ts
import { ensureEndingSlash } from "@vuepress/helper";
import { getDirname, path as path2 } from "vuepress/utils";
var __dirname = getDirname(import.meta.url);
var CLIENT_FOLDER = ensureEndingSlash(
  path2.resolve(__dirname, "../client")
);
async function prepareClientConfigFile(app, {
  copyCode,
  twoslash
}) {
  return await app.writeTemp(
    "internal/plugin-shiki/client.js",
    `${twoslash ? `import { enhanceTwoslash } from '${CLIENT_FOLDER}composables/twoslash.js'` : ""}
${copyCode ? `import { useCopyCode } from '${CLIENT_FOLDER}composables/copy-code.js'` : ""}
import { useCollapsedLines } from '${CLIENT_FOLDER}composables/collapsed-lines.js'

export default {
  ${twoslash ? `enhance({ app }) {
    enhanceTwoslash(app)
  },` : ""}
  ${copyCode ? `setup() {
    useCopyCode({
      selector: __CC_SELECTOR__,
      duration: __CC_DURATION__,
    })
    useCollapsedLines()
  },` : ""}
}
`
  );
}

// src/node/shikiPlugin.ts
function shikiPlugin({
  preWrapper = true,
  lineNumbers = true,
  copyCode = true,
  collapsedLines = false,
  ...options
} = {}) {
  const copyCodeOptions = isPlainObject2(copyCode) ? copyCode : {};
  return {
    name: "@vuepress-plume/plugin-shikiji",
    define: {
      __CC_DURATION__: copyCodeOptions.duration ?? 2e3,
      __CC_SELECTOR__: `div[class*="language-"] > button.${copyCodeOptions.className || "copy"}`
    },
    clientConfigFile: (app) => prepareClientConfigFile(app, {
      copyCode: copyCode !== false,
      twoslash: options.twoslash ?? false
    }),
    extendsMarkdown: async (md, app) => {
      const start = performance.now();
      const theme = options.theme ?? { light: "github-light", dark: "github-dark" };
      if (!options.languages || !options.languages.length) {
        options.languages = await scanLanguages(app);
        if (options.languages.length) {
          logger.warn(`You have not configured \`${colors.cyan("plugins.shiki.languages")}\`. It has been detected that you are using \`${colors.green(JSON.stringify(options.languages))}\`. Please add it to the \`${colors.cyan("plugins.shiki.languages")}\` configuration.`);
        }
        if (app.env.isDebug) {
          logger.info(`scan languages in: ${(performance.now() - start).toFixed(2)}ms`);
        }
      }
      md.options.highlight = await highlight(theme, options);
      if (app.env.isDebug) {
        logger.info(`highlight Loaded in: ${(performance.now() - start).toFixed(2)}ms`);
      }
      md.use(highlightLinesPlugin);
      md.use(preWrapperPlugin, { preWrapper });
      if (preWrapper) {
        copyCodeButtonPlugin(md, app, copyCode);
        md.use(lineNumberPlugin, { lineNumbers });
        md.use(collapsedLinesPlugin, { collapsedLines });
      }
    },
    extendsMarkdownOptions: (options2) => {
      if (options2.vPre !== false) {
        const vPre2 = isPlainObject2(options2.vPre) ? options2.vPre : { block: true };
        if (vPre2.block) {
          options2.vPre ??= {};
          options2.vPre.block = false;
        }
      }
    }
  };
}

// src/node/index.ts
var node_default = shikiPlugin;
export {
  node_default as default,
  shikiPlugin
};
