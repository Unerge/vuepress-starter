// src/node/searchPlugin.ts
import { addViteOptimizeDepsInclude } from "@vuepress/helper";
import chokidar from "chokidar";
import { getDirname, path } from "vuepress/utils";

// src/node/prepareSearchIndex.ts
import MiniSearch from "minisearch";
import pMap from "p-map";
import { colors, logger } from "vuepress/utils";
var SEARCH_INDEX_DIR = "internal/minisearchIndex/";
var indexByLocales = /* @__PURE__ */ new Map();
var indexCache = /* @__PURE__ */ new Map();
function getIndexByLocale(locale, options) {
  let index = indexByLocales.get(locale);
  if (!index) {
    index = new MiniSearch({
      fields: ["title", "titles", "text"],
      storeFields: ["title", "titles"],
      ...options.miniSearch?.options
    });
    indexByLocales.set(locale, index);
  }
  return index;
}
function getIndexCache(filepath) {
  let index = indexCache.get(filepath);
  if (!index) {
    index = [];
    indexCache.set(filepath, index);
  }
  return index;
}
async function prepareSearchIndex({
  app,
  isSearchable,
  searchOptions
}) {
  const start = performance.now();
  const pages = isSearchable ? app.pages.filter(isSearchable) : app.pages;
  await pMap(pages, (p) => indexFile(p, searchOptions), {
    concurrency: 64
  });
  await writeTemp(app);
  if (app.env.isDebug) {
    logger.info(
      `
[${colors.green("@vuepress-plume/plugin-search")}] prepare search time spent: ${(performance.now() - start).toFixed(2)}ms`
    );
  }
}
async function onSearchIndexUpdated(filepath, {
  app,
  isSearchable,
  searchOptions
}) {
  const pages = isSearchable ? app.pages.filter(isSearchable) : app.pages;
  if (pages.some((p) => p.filePathRelative?.endsWith(filepath))) {
    await indexFile(app.pages.find((p) => p.filePathRelative?.endsWith(filepath)), searchOptions);
    await writeTemp(app);
  }
}
async function onSearchIndexRemoved(filepath, {
  app,
  isSearchable,
  searchOptions
}) {
  const pages = isSearchable ? app.pages.filter(isSearchable) : app.pages;
  if (pages.some((p) => p.filePathRelative?.endsWith(filepath))) {
    const page = app.pages.find((p) => p.filePathRelative?.endsWith(filepath));
    const fileId = page.path;
    const locale = page.pathLocale;
    const index = getIndexByLocale(locale, searchOptions);
    const cache = getIndexCache(fileId);
    index.removeAll(cache);
    await writeTemp(app);
  }
}
async function writeTemp(app) {
  const records = [];
  for (const [locale] of indexByLocales) {
    const index = indexByLocales.get(locale);
    const localeName = locale.replace(/^\/|\/$/g, "").replace(/\//g, "_") || "default";
    const filename = `searchBox-${localeName}.js`;
    records.push(`${JSON.stringify(locale)}: () => import('@${SEARCH_INDEX_DIR}${filename}')`);
    await app.writeTemp(
      `${SEARCH_INDEX_DIR}${filename}`,
      `export default ${JSON.stringify(
        JSON.stringify(index) ?? {}
      )}`
    );
  }
  await app.writeTemp(
    `${SEARCH_INDEX_DIR}index.js`,
    `export const searchIndex = {${records.join(",")}}${app.env.isDev ? `
${genHmrCode("searchIndex")}` : ""}`
  );
}
async function indexFile(page, options) {
  const fileId = page.path;
  const locale = page.pathLocale;
  const index = getIndexByLocale(locale, options);
  const cache = getIndexCache(fileId);
  const html = page.contentRendered;
  const sections = splitPageIntoSections(html);
  if (cache && cache.length)
    index.removeAll(cache);
  for await (const section of sections) {
    if (!section || !(section.text || section.titles))
      break;
    const { anchor, text, titles } = section;
    const id = anchor ? [fileId, anchor].join("#") : fileId;
    const item = {
      id,
      text,
      title: titles.at(-1),
      titles: titles.slice(0, -1)
    };
    index.add(item);
    cache.push(item);
  }
}
var headingRegex = /<h(\d*).*?>(<a.*? href="#.*?".*?>.*?<\/a>)<\/h\1>/gi;
var headingContentRegex = /<a.*? href="#(.*?)".*?>(.*?)<\/a>/i;
function* splitPageIntoSections(html) {
  const result = html.split(headingRegex);
  result.shift();
  let parentTitles = [];
  for (let i = 0; i < result.length; i += 3) {
    const level = Number.parseInt(result[i]) - 1;
    const heading = result[i + 1];
    const headingResult = headingContentRegex.exec(heading);
    const title = clearHtmlTags(headingResult?.[2] ?? "").trim();
    const anchor = headingResult?.[1] ?? "";
    const content = result[i + 2];
    if (!title || !content)
      continue;
    const titles = parentTitles.slice(0, level);
    titles[level] = title;
    yield { anchor, titles, text: getSearchableText(content) };
    if (level === 0)
      parentTitles = [title];
    else
      parentTitles[level] = title;
  }
}
function getSearchableText(content) {
  content = clearHtmlTags(content);
  return content;
}
function clearHtmlTags(str) {
  return str.replace(/<[^>]*>/g, "");
}
function genHmrCode(m) {
  const func = `update${m[0].toUpperCase()}${m.slice(1)}`;
  return `
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.${m}) {
    __VUE_HMR_RUNTIME__.${func}(${m})
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ ${m} }) => {
    __VUE_HMR_RUNTIME__.${func}(${m})
  })
}
`;
}

// src/node/searchPlugin.ts
var __dirname = getDirname(import.meta.url);
function searchPlugin({
  locales = {},
  isSearchable,
  ...searchOptions
} = {}) {
  return (app) => ({
    name: "@vuepress-plume/plugin-search",
    clientConfigFile: path.resolve(__dirname, "../client/config.js"),
    define: {
      __SEARCH_LOCALES__: locales,
      __SEARCH_OPTIONS__: searchOptions
    },
    extendsBundlerOptions(bundlerOptions) {
      addViteOptimizeDepsInclude(bundlerOptions, app, ["mark.js/src/vanilla.js", "@vueuse/integrations/useFocusTrap", "minisearch"]);
    },
    onPrepared: (app2) => prepareSearchIndex({ app: app2, isSearchable, searchOptions }),
    onWatched: (app2, watchers) => {
      const searchIndexWatcher = chokidar.watch("pages/**/*.js", {
        cwd: app2.dir.temp(),
        ignoreInitial: true
      });
      searchIndexWatcher.on("add", (filepath) => {
        onSearchIndexUpdated(filepath, { app: app2, isSearchable, searchOptions });
      });
      searchIndexWatcher.on("change", (filepath) => {
        onSearchIndexUpdated(filepath, { app: app2, isSearchable, searchOptions });
      });
      searchIndexWatcher.on("unlink", (filepath) => {
        onSearchIndexRemoved(filepath, { app: app2, isSearchable, searchOptions });
      });
      watchers.push(searchIndexWatcher);
    }
  });
}

// src/node/index.ts
export * from "../shared/index.js";
export {
  prepareSearchIndex,
  searchPlugin
};
