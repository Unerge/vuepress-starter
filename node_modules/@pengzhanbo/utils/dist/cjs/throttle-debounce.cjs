"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;
exports.throttle = throttle;
function throttle(delay, callback, options) {
  const {
    noTrailing = false,
    noLeading = false,
    debounceMode = void 0
  } = options || {};
  let timeoutID;
  let cancelled = false;
  let lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) clearTimeout(timeoutID);
  }
  function cancel(options2 = {}) {
    const {
      upcomingOnly = false
    } = options2 || {};
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper(...args) {
    const self = this;
    const elapsed = Date.now() - lastExec;
    if (cancelled) return;
    function exec() {
      lastExec = Date.now();
      callback.apply(self, args);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) timeoutID = setTimeout(debounceMode ? clear : exec, delay);
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  const {
    atBegin = false
  } = options || {};
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}