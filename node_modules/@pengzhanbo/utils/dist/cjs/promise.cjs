"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promiseParallel = promiseParallel;
exports.promiseParallelSettled = promiseParallelSettled;
exports.sleep = sleep;
var _is = require("./is.cjs");
async function sleep(ms, callback) {
  return new Promise(resolve => setTimeout(async () => {
    await callback?.();
    resolve();
  }, ms));
}
function promiseParallel(promises, concurrency = Number.POSITIVE_INFINITY) {
  promises = Array.from(promises);
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  const len = promises.length;
  return new Promise((resolve, reject) => {
    function next() {
      const index = current++;
      const promise = promises[index];
      Promise.resolve((0, _is.isFunction)(promise) ? promise() : promise).then(res => {
        result[index] = res;
        if (++resolvedCount === len) resolve(result);
        if (current < len) next();
      }).catch(reason => reject(reason));
    }
    for (let i = 0; i < concurrency && i < len; i++) next();
  });
}
function promiseParallelSettled(promises, concurrency = Number.POSITIVE_INFINITY) {
  promises = Array.from(promises);
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  const len = promises.length;
  return new Promise(resolve => {
    function resolved() {
      if (++resolvedCount === len) resolve(result);
      if (current < len) next();
    }
    function next() {
      const index = current++;
      const promise = promises[index];
      Promise.resolve((0, _is.isFunction)(promise) ? promise() : promise).then(value => {
        result[index] = {
          status: "fulfilled",
          value
        };
        resolved();
      }).catch(reason => {
        result[index] = {
          status: "rejected",
          reason
        };
        resolved();
      });
    }
    for (let i = 0; i < concurrency && i < len; i++) next();
  });
}