import { isFunction } from "./is.mjs";
export async function sleep(ms, callback) {
  return new Promise(
    (resolve) => setTimeout(async () => {
      await callback?.();
      resolve();
    }, ms)
  );
}
export function promiseParallel(promises, concurrency = Number.POSITIVE_INFINITY) {
  promises = Array.from(promises);
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  const len = promises.length;
  return new Promise((resolve, reject) => {
    function next() {
      const index = current++;
      const promise = promises[index];
      Promise.resolve(isFunction(promise) ? promise() : promise).then((res) => {
        result[index] = res;
        if (++resolvedCount === len)
          resolve(result);
        if (current < len)
          next();
      }).catch((reason) => reject(reason));
    }
    for (let i = 0; i < concurrency && i < len; i++)
      next();
  });
}
export function promiseParallelSettled(promises, concurrency = Number.POSITIVE_INFINITY) {
  promises = Array.from(promises);
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  const len = promises.length;
  return new Promise((resolve) => {
    function resolved() {
      if (++resolvedCount === len)
        resolve(result);
      if (current < len)
        next();
    }
    function next() {
      const index = current++;
      const promise = promises[index];
      Promise.resolve(isFunction(promise) ? promise() : promise).then((value) => {
        result[index] = { status: "fulfilled", value };
        resolved();
      }).catch((reason) => {
        result[index] = { status: "rejected", reason };
        resolved();
      });
    }
    for (let i = 0; i < concurrency && i < len; i++)
      next();
  });
}
