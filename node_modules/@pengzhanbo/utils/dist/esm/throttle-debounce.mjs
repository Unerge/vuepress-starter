export function throttle(delay, callback, options) {
  const {
    noTrailing = false,
    noLeading = false,
    debounceMode = void 0
  } = options || {};
  let timeoutID;
  let cancelled = false;
  let lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID)
      clearTimeout(timeoutID);
  }
  function cancel(options2 = {}) {
    const { upcomingOnly = false } = options2 || {};
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper(...args) {
    const self = this;
    const elapsed = Date.now() - lastExec;
    if (cancelled)
      return;
    function exec() {
      lastExec = Date.now();
      callback.apply(self, args);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing)
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(
        debounceMode ? clear : exec,
        debounceMode === void 0 ? delay - elapsed : delay
      );
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
export function debounce(delay, callback, options) {
  const { atBegin = false } = options || {};
  return throttle(delay, callback, { debounceMode: atBegin !== false });
}
